CCS PCM C Compiler, Version 5.008, 5967               25-mai-18 21:32

               Filename:   C:\Users\vbob\Desktop\Engenharia\7º Período\Microcontroladores\fita_led\codigo4\main.lst

               ROM used:   1074 words (13%)
                           Largest free fragment is 2048
               RAM used:   31 (8%) at main() level
                           89 (24%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   215
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.1
001A:  GOTO   01D
001B:  BTFSC  0C.1
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   031
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
*
012F:  MOVF   5F,W
0130:  ANDLW  07
0131:  MOVWF  77
0132:  RRF    5F,W
0133:  MOVWF  78
0134:  RRF    78,F
0135:  RRF    78,F
0136:  MOVLW  1F
0137:  ANDWF  78,F
0138:  MOVF   78,W
0139:  ADDWF  61,W
013A:  MOVWF  04
013B:  BCF    03.7
013C:  BTFSC  62.0
013D:  BSF    03.7
013E:  CLRF   78
013F:  INCF   78,F
0140:  INCF   77,F
0141:  GOTO   143
0142:  RLF    78,F
0143:  DECFSZ 77,F
0144:  GOTO   142
0145:  MOVF   60,F
0146:  BTFSC  03.2
0147:  GOTO   14B
0148:  MOVF   78,W
0149:  IORWF  00,F
014A:  GOTO   14E
014B:  COMF   78,F
014C:  MOVF   78,W
014D:  ANDWF  00,F
014E:  RETURN
014F:  CLRF   77
0150:  CLRF   78
0151:  MOVF   5F,W
0152:  BCF    03.0
0153:  BTFSC  60.0
0154:  ADDWF  77,F
0155:  RRF    77,F
0156:  RRF    78,F
0157:  BTFSC  60.1
0158:  ADDWF  77,F
0159:  RRF    77,F
015A:  RRF    78,F
015B:  BTFSC  60.2
015C:  ADDWF  77,F
015D:  RRF    77,F
015E:  RRF    78,F
015F:  BTFSC  60.3
0160:  ADDWF  77,F
0161:  RRF    77,F
0162:  RRF    78,F
0163:  BTFSC  60.4
0164:  ADDWF  77,F
0165:  RRF    77,F
0166:  RRF    78,F
0167:  BTFSC  60.5
0168:  ADDWF  77,F
0169:  RRF    77,F
016A:  RRF    78,F
016B:  BTFSC  60.6
016C:  ADDWF  77,F
016D:  RRF    77,F
016E:  RRF    78,F
016F:  BTFSC  60.7
0170:  ADDWF  77,F
0171:  RRF    77,F
0172:  RRF    78,F
0173:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0242:  BCF    03.5
0243:  CLRF   27
0244:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #define LCD_CLEARDISPLAY 0x01 
.................... #define LCD_RETURNHOME 0x02 
.................... #define LCD_ENTRYMODESET 0x04 
.................... #define LCD_DISPLAYCONTROL 0x08 
.................... #define LCD_CURSORSHIFT 0x10 
.................... #define LCD_FUNCTIONSET 0x20 
.................... #define LCD_SETCGRAMADDR 0x40 
.................... #define LCD_SETDDRAMADDR 0x80 
....................  
.................... // flags for display entry mode 
.................... #define LCD_ENTRYRIGHT 0x00 
.................... #define LCD_ENTRYLEFT 0x02 
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01 
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00 
....................  
.................... // flags for display on/off control 
.................... #define LCD_DISPLAYON 0x04 
.................... #define LCD_DISPLAYOFF 0x00 
.................... #define LCD_CURSORON 0x02 
.................... #define LCD_CURSOROFF 0x00 
.................... #define LCD_BLINKON 0x01 
.................... #define LCD_BLINKOFF 0x00 
....................  
.................... // flags for display/cursor shift 
.................... #define LCD_DISPLAYMOVE 0x08 
.................... #define LCD_CURSORMOVE 0x00 
.................... #define LCD_MOVERIGHT 0x04 
.................... #define LCD_MOVELEFT 0x00 
....................  
.................... // flags for function set 
.................... #define LCD_8BITMODE 0x10 
.................... #define LCD_4BITMODE 0x00 
.................... #define LCD_2LINE 0x08 
.................... #define LCD_1LINE 0x00 
.................... #define LCD_5x10DOTS 0x04 
.................... #define LCD_5x8DOTS 0x00 
....................  
.................... // flags for backlight control 
.................... #define LCD_BACKLIGHT 0x08 
.................... #define LCD_NOBACKLIGHT 0x00 
....................  
.................... #define En 0b00000100  // Enable bit 
.................... #define Rw 0b00000010  // Read/Write bit 
.................... #define Rs 0b00000001  // Register select bit 
....................  
.................... #use delay(crystal=20000000) 
*
005E:  MOVLW  70
005F:  MOVWF  04
0060:  BCF    03.7
0061:  MOVF   00,W
0062:  BTFSC  03.2
0063:  GOTO   071
0064:  MOVLW  06
0065:  MOVWF  78
0066:  CLRF   77
0067:  DECFSZ 77,F
0068:  GOTO   067
0069:  DECFSZ 78,F
006A:  GOTO   066
006B:  MOVLW  7B
006C:  MOVWF  77
006D:  DECFSZ 77,F
006E:  GOTO   06D
006F:  DECFSZ 00,F
0070:  GOTO   064
0071:  RETURN
*
00B4:  MOVLW  03
00B5:  SUBWF  5A,F
00B6:  BTFSS  03.0
00B7:  GOTO   0C2
00B8:  MOVLW  5A
00B9:  MOVWF  04
00BA:  BCF    03.7
00BB:  MOVF   00,W
00BC:  BTFSC  03.2
00BD:  GOTO   0C2
00BE:  GOTO   0C0
00BF:  GOTO   0C0
00C0:  DECFSZ 00,F
00C1:  GOTO   0BF
00C2:  RETURN
.................... #use i2c(MASTER, I2C1, FORCE_HW)  
*
0072:  BCF    14.7
0073:  BCF    0C.3
0074:  MOVF   71,W
0075:  MOVWF  13
0076:  MOVLW  02
0077:  BTFSC  14.7
0078:  GOTO   080
0079:  BTFSS  0C.3
007A:  GOTO   079
007B:  MOVLW  00
007C:  BSF    03.5
007D:  BTFSC  11.6
007E:  MOVLW  01
007F:  BCF    03.5
0080:  MOVWF  78
0081:  RETURN
....................  
.................... uint8_t _backlightval = LCD_BACKLIGHT; 
.................... uint8_t _displayControl; 
.................... uint8_t _displayFunction; 
.................... uint8_t _displayMode; 
....................  
.................... void expanderWrite(uint8_t _data) { 
....................    I2C_Start(); 
0082:  BSF    03.5
0083:  BSF    11.0
0084:  BTFSC  11.0
0085:  GOTO   084
....................    I2C_Write(0x4E); 
0086:  MOVLW  4E
0087:  MOVWF  71
0088:  BCF    03.5
0089:  CALL   072
....................    delay_ms(5);  
008A:  MOVLW  05
008B:  MOVWF  70
008C:  CALL   05E
....................    I2C_Write((int)(_data) | _backlightval); 
008D:  MOVF   6F,W
008E:  IORWF  2A,W
008F:  MOVWF  70
0090:  MOVWF  71
0091:  CALL   072
....................    I2C_stop(); 
0092:  BSF    03.5
0093:  BSF    11.2
0094:  BTFSC  11.2
0095:  GOTO   094
....................    delay_ms(1);  
0096:  MOVLW  01
0097:  MOVWF  70
0098:  BCF    03.5
0099:  CALL   05E
009A:  RETURN
.................... } 
....................  
.................... void pulseEnable(uint8_t _data) { 
....................    expanderWrite(_data | En); 
*
00A0:  MOVF   6D,W
00A1:  IORLW  04
00A2:  MOVWF  6E
00A3:  MOVWF  6F
00A4:  CALL   082
....................    delay_us(1); 
00A5:  GOTO   0A6
00A6:  GOTO   0A7
00A7:  NOP
....................     
....................    expanderWrite(_data & ~En); 
00A8:  MOVF   6D,W
00A9:  ANDLW  FB
00AA:  MOVWF  6E
00AB:  MOVWF  6F
00AC:  CALL   082
....................    delay_us(50); 
00AD:  MOVLW  52
00AE:  MOVWF  77
00AF:  DECFSZ 77,F
00B0:  GOTO   0AF
00B1:  GOTO   0B2
00B2:  NOP
.................... } 
....................  
.................... void write4bits(uint8_t value) { 
....................    expanderWrite(value); 
*
009B:  MOVF   6C,W
009C:  MOVWF  6F
009D:  CALL   082
....................    pulseEnable(value); 
009E:  MOVF   6C,W
009F:  MOVWF  6D
*
00B3:  RETURN
.................... } 
....................  
.................... void send(uint8_t value, uint8_t mode) { 
*
00C3:  MOVF   67,W
00C4:  ANDLW  F0
00C5:  MOVWF  69
00C6:  SWAPF  67,W
00C7:  MOVWF  77
00C8:  MOVLW  F0
00C9:  ANDWF  77,F
00CA:  MOVF   77,W
00CB:  ANDLW  F0
00CC:  MOVWF  6A
....................    uint8_t MSB = value & 0b11110000; 
....................    uint8_t LSB = (value << 4) & 0b11110000; 
....................    write4bits((MSB)|mode); 
00CD:  MOVF   69,W
00CE:  IORWF  68,W
00CF:  MOVWF  6B
00D0:  MOVWF  6C
00D1:  CALL   09B
....................    write4bits((LSB)|mode); 
00D2:  MOVF   6A,W
00D3:  IORWF  68,W
00D4:  MOVWF  6B
00D5:  MOVWF  6C
00D6:  CALL   09B
00D7:  RETURN
.................... } 
....................  
.................... void command(uint8_t value) { 
....................    send(value, 0); 
00D8:  MOVF   66,W
00D9:  MOVWF  67
00DA:  CLRF   68
00DB:  CALL   0C3
00DC:  RETURN
.................... } 
....................  
.................... void display() { 
....................    _displayControl |= LCD_DISPLAYON; 
00DD:  BSF    2B.2
....................    command(LCD_DISPLAYCONTROL | _displayControl); 
00DE:  MOVF   2B,W
00DF:  IORLW  08
00E0:  MOVWF  59
00E1:  MOVWF  66
00E2:  CALL   0D8
00E3:  BCF    0A.3
00E4:  BCF    0A.4
00E5:  GOTO   29F (RETURN)
.................... } 
....................  
.................... void clear() { 
....................    command(LCD_CLEARDISPLAY); 
00E6:  MOVLW  01
00E7:  MOVWF  66
00E8:  CALL   0D8
....................    delay_us(2000); 
00E9:  MOVLW  02
00EA:  MOVWF  70
00EB:  CALL   05E
00EC:  BCF    0A.3
00ED:  BCF    0A.4
00EE:  GOTO   2A0 (RETURN)
.................... } 
....................  
.................... void home() { 
....................    command(LCD_RETURNHOME); 
00EF:  MOVLW  02
00F0:  MOVWF  66
00F1:  CALL   0D8
....................    delay_us(2000); 
00F2:  MOVLW  02
00F3:  MOVWF  70
00F4:  CALL   05E
00F5:  BCF    0A.3
00F6:  BCF    0A.4
00F7:  GOTO   2A8 (RETURN)
.................... } 
....................  
.................... int write(uint8_t value) { 
....................    send(value, Rs); 
00F8:  MOVF   5E,W
00F9:  MOVWF  67
00FA:  MOVLW  01
00FB:  MOVWF  68
00FC:  CALL   0C3
....................    return 1; 
00FD:  MOVLW  01
00FE:  MOVWF  78
00FF:  RETURN
.................... } 
....................  
.................... void printstr(char *c[]) { 
0100:  CLRF   5B
....................    int i = 0; 
....................    while (c[i]) { 
0101:  MOVF   5B,W
0102:  ADDWF  59,W
0103:  MOVWF  04
0104:  BCF    03.7
0105:  BTFSC  5A.0
0106:  BSF    03.7
0107:  MOVF   00,F
0108:  BTFSC  03.2
0109:  GOTO   116
....................       write(c[i]); 
010A:  MOVF   5B,W
010B:  ADDWF  59,W
010C:  MOVWF  04
010D:  BCF    03.7
010E:  BTFSC  5A.0
010F:  BSF    03.7
0110:  MOVF   00,W
0111:  MOVWF  5C
0112:  MOVWF  5E
0113:  CALL   0F8
....................       i++; 
0114:  INCF   5B,F
0115:  GOTO   101
....................    } 
0116:  RETURN
.................... } 
....................  
.................... void setCursor(uint8_t col, uint8_t row){ 
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 }; 
0117:  CLRF   61
0118:  MOVLW  40
0119:  MOVWF  62
011A:  MOVLW  14
011B:  MOVWF  63
011C:  MOVLW  54
011D:  MOVWF  64
....................    if (row > 2) { 
011E:  MOVF   60,W
011F:  SUBLW  02
0120:  BTFSC  03.0
0121:  GOTO   124
....................       row = 2-1;    // we count rows starting w/0 
0122:  MOVLW  01
0123:  MOVWF  60
....................    } 
....................    command(LCD_SETDDRAMADDR | (col + row_offsets[row])); 
0124:  MOVLW  61
0125:  ADDWF  60,W
0126:  MOVWF  04
0127:  BCF    03.7
0128:  MOVF   00,W
0129:  ADDWF  5F,W
012A:  IORLW  80
012B:  MOVWF  65
012C:  MOVWF  66
012D:  CALL   0D8
012E:  RETURN
.................... } 
....................  
.................... #define LINHA0 PIN_B7 
.................... #define LINHA1 PIN_B6 
.................... #define LINHA2 PIN_B5 
.................... #define LINHA3 PIN_B4 
.................... #define COLUN0 PIN_B3 
.................... #define COLUN1 PIN_B2 
.................... #define COLUN2 PIN_B1 
.................... #define COLUN3 PIN_B0 
....................  
.................... #use FIXED_IO(B_outputs=PIN_B4, PIN_B5, PIN_B6, PIN_B7) 
.................... #use FIXED_IO(D_outputs=PIN_D0, PIN_D1, PIN_D2) 
.................... #use FIXED_IO(C_outputs=PIN_C5) 
.................... uint8_t pos_cursor = 1; 
....................  
.................... uint16_t red = 0; 
.................... uint16_t green = 0; 
.................... uint16_t blue = 0; 
....................  
.................... uint8_t red1 = 0; 
.................... uint8_t green1 = 0; 
.................... uint8_t blue1 = 0; 
....................  
.................... #define RED_PIN PIN_D1 
.................... #define GREEN_PIN PIN_D0 
.................... #define BLUE_PIN PIN_D2 
....................  
.................... void jumpCursor(int digited) { 
....................    if (pos_cursor == 2) { 
*
0174:  MOVF   2E,W
0175:  SUBLW  02
0176:  BTFSS  03.2
0177:  GOTO   180
....................        red = digited*100; 
0178:  MOVF   5E,W
0179:  MOVWF  5F
017A:  MOVLW  64
017B:  MOVWF  60
017C:  CALL   14F
017D:  CLRF   30
017E:  MOVF   78,W
017F:  MOVWF  2F
....................    } 
....................    if (pos_cursor == 3) { 
0180:  MOVF   2E,W
0181:  SUBLW  03
0182:  BTFSS  03.2
0183:  GOTO   18D
....................        red+=digited*10; 
0184:  MOVF   5E,W
0185:  MOVWF  5F
0186:  MOVLW  0A
0187:  MOVWF  60
0188:  CALL   14F
0189:  MOVF   78,W
018A:  ADDWF  2F,F
018B:  BTFSC  03.0
018C:  INCF   30,F
....................    } 
....................    if (pos_cursor == 4) { 
018D:  MOVF   2E,W
018E:  SUBLW  04
018F:  BTFSS  03.2
0190:  GOTO   1A9
....................       red+=digited; 
0191:  MOVF   5E,W
0192:  ADDWF  2F,F
0193:  BTFSC  03.0
0194:  INCF   30,F
....................       if (red>255) { 
0195:  MOVF   30,W
0196:  SUBLW  00
0197:  BTFSC  03.0
0198:  GOTO   1A0
....................          setCursor(1,1); 
0199:  MOVLW  01
019A:  MOVWF  5F
019B:  MOVWF  60
019C:  CALL   117
....................          pos_cursor = 1; 
019D:  MOVLW  01
019E:  MOVWF  2E
....................       } 
019F:  GOTO   1A9
....................       else { 
....................          setCursor(6,1); 
01A0:  MOVLW  06
01A1:  MOVWF  5F
01A2:  MOVLW  01
01A3:  MOVWF  60
01A4:  CALL   117
....................          pos_cursor = 6; 
01A5:  MOVLW  06
01A6:  MOVWF  2E
....................          red1 = red; 
01A7:  MOVF   2F,W
01A8:  MOVWF  35
....................       } 
....................        
....................    } 
....................    if (pos_cursor == 7) { 
01A9:  MOVF   2E,W
01AA:  SUBLW  07
01AB:  BTFSS  03.2
01AC:  GOTO   1B5
....................        green = digited * 100; 
01AD:  MOVF   5E,W
01AE:  MOVWF  5F
01AF:  MOVLW  64
01B0:  MOVWF  60
01B1:  CALL   14F
01B2:  CLRF   32
01B3:  MOVF   78,W
01B4:  MOVWF  31
....................    } 
....................    if (pos_cursor ==8) { 
01B5:  MOVF   2E,W
01B6:  SUBLW  08
01B7:  BTFSS  03.2
01B8:  GOTO   1C2
....................        green += digited * 10; 
01B9:  MOVF   5E,W
01BA:  MOVWF  5F
01BB:  MOVLW  0A
01BC:  MOVWF  60
01BD:  CALL   14F
01BE:  MOVF   78,W
01BF:  ADDWF  31,F
01C0:  BTFSC  03.0
01C1:  INCF   32,F
....................    } 
....................    if (pos_cursor == 9) { 
01C2:  MOVF   2E,W
01C3:  SUBLW  09
01C4:  BTFSS  03.2
01C5:  GOTO   1DF
....................       green += digited; 
01C6:  MOVF   5E,W
01C7:  ADDWF  31,F
01C8:  BTFSC  03.0
01C9:  INCF   32,F
....................        if (green>255) { 
01CA:  MOVF   32,W
01CB:  SUBLW  00
01CC:  BTFSC  03.0
01CD:  GOTO   1D6
....................          setCursor(6,1); 
01CE:  MOVLW  06
01CF:  MOVWF  5F
01D0:  MOVLW  01
01D1:  MOVWF  60
01D2:  CALL   117
....................          pos_cursor = 6; 
01D3:  MOVLW  06
01D4:  MOVWF  2E
....................       } 
01D5:  GOTO   1DF
....................       else { 
....................          setCursor(11,1); 
01D6:  MOVLW  0B
01D7:  MOVWF  5F
01D8:  MOVLW  01
01D9:  MOVWF  60
01DA:  CALL   117
....................          pos_cursor = 11; 
01DB:  MOVLW  0B
01DC:  MOVWF  2E
....................          green1 = green; 
01DD:  MOVF   31,W
01DE:  MOVWF  36
....................       } 
....................    } 
....................    if (pos_cursor == 12) { 
01DF:  MOVF   2E,W
01E0:  SUBLW  0C
01E1:  BTFSS  03.2
01E2:  GOTO   1EB
....................        blue = digited * 100; 
01E3:  MOVF   5E,W
01E4:  MOVWF  5F
01E5:  MOVLW  64
01E6:  MOVWF  60
01E7:  CALL   14F
01E8:  CLRF   34
01E9:  MOVF   78,W
01EA:  MOVWF  33
....................    } 
....................    if (pos_cursor ==13) { 
01EB:  MOVF   2E,W
01EC:  SUBLW  0D
01ED:  BTFSS  03.2
01EE:  GOTO   1F8
....................        blue += digited * 10; 
01EF:  MOVF   5E,W
01F0:  MOVWF  5F
01F1:  MOVLW  0A
01F2:  MOVWF  60
01F3:  CALL   14F
01F4:  MOVF   78,W
01F5:  ADDWF  33,F
01F6:  BTFSC  03.0
01F7:  INCF   34,F
....................    } 
....................    if (pos_cursor == 14) { 
01F8:  MOVF   2E,W
01F9:  SUBLW  0E
01FA:  BTFSS  03.2
01FB:  GOTO   214
....................       blue += digited; 
01FC:  MOVF   5E,W
01FD:  ADDWF  33,F
01FE:  BTFSC  03.0
01FF:  INCF   34,F
....................        
....................        
....................       if (blue>255) { 
0200:  MOVF   34,W
0201:  SUBLW  00
0202:  BTFSC  03.0
0203:  GOTO   20C
....................          setCursor(11,1); 
0204:  MOVLW  0B
0205:  MOVWF  5F
0206:  MOVLW  01
0207:  MOVWF  60
0208:  CALL   117
....................          pos_cursor = 1; 
0209:  MOVLW  01
020A:  MOVWF  2E
....................       } 
020B:  GOTO   214
....................       else { 
....................          setCursor(1,1); 
020C:  MOVLW  01
020D:  MOVWF  5F
020E:  MOVWF  60
020F:  CALL   117
....................          pos_cursor = 1; 
0210:  MOVLW  01
0211:  MOVWF  2E
....................          blue1 = blue; 
0212:  MOVF   33,W
0213:  MOVWF  37
....................       } 
....................    } 
0214:  RETURN
.................... } 
....................  
.................... void scanPorts() { 
....................    uint8_t ports[] = {LINHA0, LINHA1, LINHA2, LINHA3}; 
*
02FB:  MOVLW  37
02FC:  MOVWF  59
02FD:  MOVLW  36
02FE:  MOVWF  5A
02FF:  MOVLW  35
0300:  MOVWF  5B
0301:  MOVLW  34
0302:  MOVWF  5C
....................  
....................    for (int linha = 0; linha <= 3; linha++) { 
0303:  CLRF   5D
0304:  MOVF   5D,W
0305:  SUBLW  03
0306:  BTFSS  03.0
0307:  GOTO   430
....................       output_high(ports[0]); 
0308:  MOVF   59,W
0309:  MOVWF  5F
030A:  MOVLW  01
030B:  MOVWF  60
030C:  CLRF   62
030D:  CLRF   61
030E:  CALL   12F
030F:  MOVF   59,W
0310:  MOVWF  5F
0311:  CLRF   60
0312:  CLRF   62
0313:  MOVLW  80
0314:  MOVWF  61
0315:  CALL   12F
....................       output_high(ports[1]); 
0316:  MOVF   5A,W
0317:  MOVWF  5F
0318:  MOVLW  01
0319:  MOVWF  60
031A:  CLRF   62
031B:  CLRF   61
031C:  CALL   12F
031D:  MOVF   5A,W
031E:  MOVWF  5F
031F:  CLRF   60
0320:  CLRF   62
0321:  MOVLW  80
0322:  MOVWF  61
0323:  CALL   12F
....................       output_high(ports[2]); 
0324:  MOVF   5B,W
0325:  MOVWF  5F
0326:  MOVLW  01
0327:  MOVWF  60
0328:  CLRF   62
0329:  CLRF   61
032A:  CALL   12F
032B:  MOVF   5B,W
032C:  MOVWF  5F
032D:  CLRF   60
032E:  CLRF   62
032F:  MOVLW  80
0330:  MOVWF  61
0331:  CALL   12F
....................       output_high(ports[3]); 
0332:  MOVF   5C,W
0333:  MOVWF  5F
0334:  MOVLW  01
0335:  MOVWF  60
0336:  CLRF   62
0337:  CLRF   61
0338:  CALL   12F
0339:  MOVF   5C,W
033A:  MOVWF  5F
033B:  CLRF   60
033C:  CLRF   62
033D:  MOVLW  80
033E:  MOVWF  61
033F:  CALL   12F
....................       output_low(ports[linha]); 
0340:  MOVLW  59
0341:  ADDWF  5D,W
0342:  MOVWF  04
0343:  BCF    03.7
0344:  MOVF   00,W
0345:  MOVWF  5E
0346:  MOVWF  5F
0347:  CLRF   60
0348:  CLRF   62
0349:  CLRF   61
034A:  CALL   12F
034B:  MOVF   5E,W
034C:  MOVWF  5F
034D:  CLRF   60
034E:  CLRF   62
034F:  MOVLW  80
0350:  MOVWF  61
0351:  CALL   12F
....................        
....................       if (linha == 0 && !input(COLUN0)) { 
0352:  MOVF   5D,F
0353:  BTFSS  03.2
0354:  GOTO   368
0355:  MOVLW  0F
0356:  BSF    03.5
0357:  MOVWF  06
0358:  BCF    03.5
0359:  BTFSC  06.3
035A:  GOTO   368
....................          write('1'); 
035B:  MOVLW  31
035C:  MOVWF  5E
035D:  CALL   0F8
....................          pos_cursor++; 
035E:  INCF   2E,F
....................          jumpCursor(1); 
035F:  MOVLW  01
0360:  MOVWF  5E
0361:  CALL   174
....................          while(!input(COLUN0)); 
0362:  MOVLW  0F
0363:  BSF    03.5
0364:  MOVWF  06
0365:  BCF    03.5
0366:  BTFSS  06.3
0367:  GOTO   362
....................       } 
....................       if (linha == 0 && !input(COLUN1)) { 
0368:  MOVF   5D,F
0369:  BTFSS  03.2
036A:  GOTO   37E
036B:  MOVLW  0F
036C:  BSF    03.5
036D:  MOVWF  06
036E:  BCF    03.5
036F:  BTFSC  06.2
0370:  GOTO   37E
....................          write('2'); 
0371:  MOVLW  32
0372:  MOVWF  5E
0373:  CALL   0F8
....................          pos_cursor++; 
0374:  INCF   2E,F
....................          jumpCursor(2); 
0375:  MOVLW  02
0376:  MOVWF  5E
0377:  CALL   174
....................          while(!input(COLUN1)); 
0378:  MOVLW  0F
0379:  BSF    03.5
037A:  MOVWF  06
037B:  BCF    03.5
037C:  BTFSS  06.2
037D:  GOTO   378
....................       } 
....................       if (linha == 0 && !input(COLUN2)) { 
037E:  MOVF   5D,F
037F:  BTFSS  03.2
0380:  GOTO   394
0381:  MOVLW  0F
0382:  BSF    03.5
0383:  MOVWF  06
0384:  BCF    03.5
0385:  BTFSC  06.1
0386:  GOTO   394
....................          write('3'); 
0387:  MOVLW  33
0388:  MOVWF  5E
0389:  CALL   0F8
....................          pos_cursor++; 
038A:  INCF   2E,F
....................          jumpCursor(3); 
038B:  MOVLW  03
038C:  MOVWF  5E
038D:  CALL   174
....................          while(!input(COLUN2)); 
038E:  MOVLW  0F
038F:  BSF    03.5
0390:  MOVWF  06
0391:  BCF    03.5
0392:  BTFSS  06.1
0393:  GOTO   38E
....................       } 
....................       if (linha == 1 && !input(COLUN0)) { 
0394:  DECFSZ 5D,W
0395:  GOTO   3A9
0396:  MOVLW  0F
0397:  BSF    03.5
0398:  MOVWF  06
0399:  BCF    03.5
039A:  BTFSC  06.3
039B:  GOTO   3A9
....................          write('4'); 
039C:  MOVLW  34
039D:  MOVWF  5E
039E:  CALL   0F8
....................          pos_cursor++; 
039F:  INCF   2E,F
....................          jumpCursor(4); 
03A0:  MOVLW  04
03A1:  MOVWF  5E
03A2:  CALL   174
....................          while(!input(COLUN0)); 
03A3:  MOVLW  0F
03A4:  BSF    03.5
03A5:  MOVWF  06
03A6:  BCF    03.5
03A7:  BTFSS  06.3
03A8:  GOTO   3A3
....................       } 
....................       if (linha == 1 && !input(COLUN1)) { 
03A9:  DECFSZ 5D,W
03AA:  GOTO   3BE
03AB:  MOVLW  0F
03AC:  BSF    03.5
03AD:  MOVWF  06
03AE:  BCF    03.5
03AF:  BTFSC  06.2
03B0:  GOTO   3BE
....................          write('5'); 
03B1:  MOVLW  35
03B2:  MOVWF  5E
03B3:  CALL   0F8
....................          pos_cursor++; 
03B4:  INCF   2E,F
....................          jumpCursor(5); 
03B5:  MOVLW  05
03B6:  MOVWF  5E
03B7:  CALL   174
....................          while(!input(COLUN1)); 
03B8:  MOVLW  0F
03B9:  BSF    03.5
03BA:  MOVWF  06
03BB:  BCF    03.5
03BC:  BTFSS  06.2
03BD:  GOTO   3B8
....................       } 
....................       if (linha == 1 && !input(COLUN2)) { 
03BE:  DECFSZ 5D,W
03BF:  GOTO   3D3
03C0:  MOVLW  0F
03C1:  BSF    03.5
03C2:  MOVWF  06
03C3:  BCF    03.5
03C4:  BTFSC  06.1
03C5:  GOTO   3D3
....................          write('6'); 
03C6:  MOVLW  36
03C7:  MOVWF  5E
03C8:  CALL   0F8
....................          pos_cursor++; 
03C9:  INCF   2E,F
....................          jumpCursor(6); 
03CA:  MOVLW  06
03CB:  MOVWF  5E
03CC:  CALL   174
....................          while(!input(COLUN2)); 
03CD:  MOVLW  0F
03CE:  BSF    03.5
03CF:  MOVWF  06
03D0:  BCF    03.5
03D1:  BTFSS  06.1
03D2:  GOTO   3CD
....................       } 
....................       if (linha == 2 && !input(COLUN0)) { 
03D3:  MOVF   5D,W
03D4:  SUBLW  02
03D5:  BTFSS  03.2
03D6:  GOTO   3EA
03D7:  MOVLW  0F
03D8:  BSF    03.5
03D9:  MOVWF  06
03DA:  BCF    03.5
03DB:  BTFSC  06.3
03DC:  GOTO   3EA
....................          write('7'); 
03DD:  MOVLW  37
03DE:  MOVWF  5E
03DF:  CALL   0F8
....................          pos_cursor++; 
03E0:  INCF   2E,F
....................          jumpCursor(7); 
03E1:  MOVLW  07
03E2:  MOVWF  5E
03E3:  CALL   174
....................          while(!input(COLUN0)); 
03E4:  MOVLW  0F
03E5:  BSF    03.5
03E6:  MOVWF  06
03E7:  BCF    03.5
03E8:  BTFSS  06.3
03E9:  GOTO   3E4
....................       } 
....................       if (linha == 2 && !input(COLUN1)) { 
03EA:  MOVF   5D,W
03EB:  SUBLW  02
03EC:  BTFSS  03.2
03ED:  GOTO   401
03EE:  MOVLW  0F
03EF:  BSF    03.5
03F0:  MOVWF  06
03F1:  BCF    03.5
03F2:  BTFSC  06.2
03F3:  GOTO   401
....................          write('8'); 
03F4:  MOVLW  38
03F5:  MOVWF  5E
03F6:  CALL   0F8
....................          pos_cursor++; 
03F7:  INCF   2E,F
....................          jumpCursor(8); 
03F8:  MOVLW  08
03F9:  MOVWF  5E
03FA:  CALL   174
....................          while(!input(COLUN1)); 
03FB:  MOVLW  0F
03FC:  BSF    03.5
03FD:  MOVWF  06
03FE:  BCF    03.5
03FF:  BTFSS  06.2
0400:  GOTO   3FB
....................       } 
....................       if (linha == 2 && !input(COLUN2)) { 
0401:  MOVF   5D,W
0402:  SUBLW  02
0403:  BTFSS  03.2
0404:  GOTO   418
0405:  MOVLW  0F
0406:  BSF    03.5
0407:  MOVWF  06
0408:  BCF    03.5
0409:  BTFSC  06.1
040A:  GOTO   418
....................          write('9'); 
040B:  MOVLW  39
040C:  MOVWF  5E
040D:  CALL   0F8
....................          pos_cursor++; 
040E:  INCF   2E,F
....................          jumpCursor(9); 
040F:  MOVLW  09
0410:  MOVWF  5E
0411:  CALL   174
....................          while(!input(COLUN2)); 
0412:  MOVLW  0F
0413:  BSF    03.5
0414:  MOVWF  06
0415:  BCF    03.5
0416:  BTFSS  06.1
0417:  GOTO   412
....................       } 
....................       if (linha == 3 && !input(COLUN1)) { 
0418:  MOVF   5D,W
0419:  SUBLW  03
041A:  BTFSS  03.2
041B:  GOTO   42E
041C:  MOVLW  0F
041D:  BSF    03.5
041E:  MOVWF  06
041F:  BCF    03.5
0420:  BTFSC  06.2
0421:  GOTO   42E
....................          write('0'); 
0422:  MOVLW  30
0423:  MOVWF  5E
0424:  CALL   0F8
....................          pos_cursor++; 
0425:  INCF   2E,F
....................          jumpCursor(0); 
0426:  CLRF   5E
0427:  CALL   174
....................          while(!input(COLUN1)); 
0428:  MOVLW  0F
0429:  BSF    03.5
042A:  MOVWF  06
042B:  BCF    03.5
042C:  BTFSS  06.2
042D:  GOTO   428
....................       } 
042E:  INCF   5D,F
042F:  GOTO   304
....................    } 
.................... } 
....................  
.................... uint8_t counter = 0; 
....................  
....................  
.................... #INT_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    output_d(0b00000000 | ((red1>counter)<<1) | ((blue1>counter)<<2) | ((green1>counter))); 
*
0031:  MOVF   35,W
0032:  SUBWF  38,W
0033:  BTFSS  03.0
0034:  GOTO   037
0035:  MOVLW  00
0036:  GOTO   038
0037:  MOVLW  01
0038:  MOVWF  77
0039:  BCF    03.0
003A:  RLF    77,F
003B:  MOVF   77,W
003C:  MOVWF  72
003D:  MOVF   37,W
003E:  SUBWF  38,W
003F:  BTFSS  03.0
0040:  GOTO   043
0041:  MOVLW  00
0042:  GOTO   044
0043:  MOVLW  01
0044:  MOVWF  77
0045:  RLF    77,F
0046:  RLF    77,F
0047:  MOVLW  FC
0048:  ANDWF  77,F
0049:  MOVF   77,W
004A:  IORWF  72,F
004B:  MOVF   36,W
004C:  SUBWF  38,W
004D:  BTFSS  03.0
004E:  GOTO   051
004F:  MOVLW  00
0050:  GOTO   052
0051:  MOVLW  01
0052:  IORWF  72,F
0053:  MOVLW  F8
0054:  BSF    03.5
0055:  MOVWF  08
0056:  MOVF   72,W
0057:  BCF    03.5
0058:  MOVWF  08
....................    counter++; 
0059:  INCF   38,F
005A:  BCF    0C.1
005B:  BCF    0A.3
005C:  BCF    0A.4
005D:  GOTO   01D
.................... } 
....................  
....................  
.................... void main() 
*
0215:  MOVF   03,W
0216:  ANDLW  1F
0217:  MOVWF  03
0218:  MOVLW  FF
0219:  MOVWF  29
021A:  BSF    29.3
021B:  MOVF   29,W
021C:  BSF    03.5
021D:  MOVWF  07
021E:  BCF    03.5
021F:  BSF    29.4
0220:  MOVF   29,W
0221:  BSF    03.5
0222:  MOVWF  07
0223:  MOVLW  31
0224:  MOVWF  13
0225:  MOVLW  28
0226:  BCF    03.5
0227:  MOVWF  14
0228:  BSF    03.5
0229:  BSF    14.7
022A:  BCF    14.6
022B:  MOVLW  08
022C:  BCF    03.5
022D:  MOVWF  2A
022E:  MOVLW  01
022F:  MOVWF  2E
0230:  CLRF   30
0231:  CLRF   2F
0232:  CLRF   32
0233:  CLRF   31
0234:  CLRF   34
0235:  CLRF   33
0236:  CLRF   35
0237:  CLRF   36
0238:  CLRF   37
0239:  CLRF   38
023A:  BSF    03.5
023B:  BSF    1F.0
023C:  BSF    1F.1
023D:  BSF    1F.2
023E:  BCF    1F.3
023F:  MOVLW  07
0240:  MOVWF  1C
0241:  BCF    03.7
.................... { 
....................    enable_interrupts(INT_TIMER2); 
*
0245:  BSF    03.5
0246:  BSF    0C.1
....................    enable_interrupts(GLOBAL); 
0247:  MOVLW  C0
0248:  BCF    03.5
0249:  IORWF  0B,F
....................  
....................    setup_timer_2(T2_DIV_BY_4,1,16); 
024A:  MOVLW  78
024B:  MOVWF  78
024C:  IORLW  05
024D:  MOVWF  12
024E:  MOVLW  01
024F:  BSF    03.5
0250:  MOVWF  12
....................  
....................    port_B_pullups(0xFF); 
0251:  BCF    01.7
....................    delay_ms(1000); 
0252:  MOVLW  04
0253:  BCF    03.5
0254:  MOVWF  59
0255:  MOVLW  FA
0256:  MOVWF  70
0257:  CALL   05E
0258:  DECFSZ 59,F
0259:  GOTO   255
....................    _displayFunction = LCD_4BITMODE | LCD_2LINE | LCD_5x8DOTS; 
025A:  MOVLW  08
025B:  MOVWF  2C
....................    delay_ms(500); 
025C:  MOVLW  02
025D:  MOVWF  59
025E:  MOVLW  FA
025F:  MOVWF  70
0260:  CALL   05E
0261:  DECFSZ 59,F
0262:  GOTO   25E
....................    expanderWrite(_backlightval); 
0263:  MOVF   2A,W
0264:  MOVWF  6F
0265:  CALL   082
....................    delay_ms(1000); 
0266:  MOVLW  04
0267:  MOVWF  59
0268:  MOVLW  FA
0269:  MOVWF  70
026A:  CALL   05E
026B:  DECFSZ 59,F
026C:  GOTO   268
....................     
....................    write4bits(0x03 << 4); 
026D:  MOVLW  30
026E:  MOVWF  6C
026F:  CALL   09B
....................    delay_us(4500); 
0270:  MOVLW  04
0271:  MOVWF  70
0272:  CALL   05E
0273:  MOVLW  02
0274:  MOVWF  59
0275:  MOVLW  F9
0276:  MOVWF  5A
0277:  CALL   0B4
0278:  DECFSZ 59,F
0279:  GOTO   275
....................     
....................    write4bits(0x03 << 4); 
027A:  MOVLW  30
027B:  MOVWF  6C
027C:  CALL   09B
....................    delay_us(4500); 
027D:  MOVLW  04
027E:  MOVWF  70
027F:  CALL   05E
0280:  MOVLW  02
0281:  MOVWF  59
0282:  MOVLW  F9
0283:  MOVWF  5A
0284:  CALL   0B4
0285:  DECFSZ 59,F
0286:  GOTO   282
....................     
....................    write4bits(0x03 << 4); 
0287:  MOVLW  30
0288:  MOVWF  6C
0289:  CALL   09B
....................    delay_us(1500); 
028A:  MOVLW  01
028B:  MOVWF  70
028C:  CALL   05E
028D:  MOVLW  02
028E:  MOVWF  59
028F:  MOVLW  F9
0290:  MOVWF  5A
0291:  CALL   0B4
0292:  DECFSZ 59,F
0293:  GOTO   28F
....................     
....................    write4bits(0x02 << 4); 
0294:  MOVLW  20
0295:  MOVWF  6C
0296:  CALL   09B
....................     
....................    command(LCD_FUNCTIONSET | _displayFunction); 
0297:  MOVF   2C,W
0298:  IORLW  20
0299:  MOVWF  59
029A:  MOVWF  66
029B:  CALL   0D8
....................     
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSORON | LCD_BLINKON; 
029C:  MOVLW  07
029D:  MOVWF  2B
....................     
....................    display(); 
029E:  GOTO   0DD
....................    clear(); 
029F:  GOTO   0E6
....................     
....................    _displayMode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT; 
02A0:  MOVLW  02
02A1:  MOVWF  2D
....................     
....................    command(LCD_ENTRYMODESET | _displayMode); 
02A2:  MOVF   2D,W
02A3:  IORLW  04
02A4:  MOVWF  59
02A5:  MOVWF  66
02A6:  CALL   0D8
....................     
....................    home(); 
02A7:  GOTO   0EF
....................     
....................    char c[16] = "Escolha a cor: "; 
02A8:  MOVLW  45
02A9:  MOVWF  39
02AA:  MOVLW  73
02AB:  MOVWF  3A
02AC:  MOVLW  63
02AD:  MOVWF  3B
02AE:  MOVLW  6F
02AF:  MOVWF  3C
02B0:  MOVLW  6C
02B1:  MOVWF  3D
02B2:  MOVLW  68
02B3:  MOVWF  3E
02B4:  MOVLW  61
02B5:  MOVWF  3F
02B6:  MOVLW  20
02B7:  MOVWF  40
02B8:  MOVLW  61
02B9:  MOVWF  41
02BA:  MOVLW  20
02BB:  MOVWF  42
02BC:  MOVLW  63
02BD:  MOVWF  43
02BE:  MOVLW  6F
02BF:  MOVWF  44
02C0:  MOVLW  72
02C1:  MOVWF  45
02C2:  MOVLW  3A
02C3:  MOVWF  46
02C4:  MOVLW  20
02C5:  MOVWF  47
02C6:  CLRF   48
....................    printstr(c); 
02C7:  CLRF   5A
02C8:  MOVLW  39
02C9:  MOVWF  59
02CA:  CALL   100
....................     
....................    setCursor(0,1); 
02CB:  CLRF   5F
02CC:  MOVLW  01
02CD:  MOVWF  60
02CE:  CALL   117
....................    char d[16] = "R000 G000 B000"; 
02CF:  MOVLW  52
02D0:  MOVWF  49
02D1:  MOVLW  30
02D2:  MOVWF  4A
02D3:  MOVWF  4B
02D4:  MOVWF  4C
02D5:  MOVLW  20
02D6:  MOVWF  4D
02D7:  MOVLW  47
02D8:  MOVWF  4E
02D9:  MOVLW  30
02DA:  MOVWF  4F
02DB:  MOVWF  50
02DC:  MOVWF  51
02DD:  MOVLW  20
02DE:  MOVWF  52
02DF:  MOVLW  42
02E0:  MOVWF  53
02E1:  MOVLW  30
02E2:  MOVWF  54
02E3:  MOVWF  55
02E4:  MOVWF  56
02E5:  CLRF   57
....................    printstr(d); 
02E6:  CLRF   5A
02E7:  MOVLW  49
02E8:  MOVWF  59
02E9:  CALL   100
....................     
....................    setCursor(1,1); 
02EA:  MOVLW  01
02EB:  MOVWF  5F
02EC:  MOVWF  60
02ED:  CALL   117
....................     
....................    output_high(BLUE_PIN); 
02EE:  MOVLW  F8
02EF:  BSF    03.5
02F0:  MOVWF  08
02F1:  BCF    03.5
02F2:  BSF    08.2
....................    output_high(GREEN_PIN); 
02F3:  BSF    03.5
02F4:  MOVWF  08
02F5:  BCF    03.5
02F6:  BSF    08.0
....................    output_high(RED_PIN); 
02F7:  BSF    03.5
02F8:  MOVWF  08
02F9:  BCF    03.5
02FA:  BSF    08.1
....................     
....................    while(TRUE) scanPorts(); 
*
0430:  GOTO   2FB
.................... } 
....................  
0431:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
