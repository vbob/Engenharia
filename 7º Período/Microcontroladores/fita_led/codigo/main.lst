CCS PCM C Compiler, Version 5.008, 5967               04-jun-18 09:44

               Filename:   C:\Users\vbob\Desktop\Engenharia\7º Período\Microcontroladores\fita_led\codigo\main.lst

               ROM used:   1768 words (22%)
                           Largest free fragment is 2048
               RAM used:   71 (19%) at main() level
                           161 (44%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   37D
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.1
001A:  GOTO   01D
001B:  BTFSC  0C.1
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   031
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
*
01C1:  BSF    03.5
01C2:  MOVF   43,W
01C3:  CLRF   78
01C4:  SUBWF  42,W
01C5:  BTFSC  03.0
01C6:  GOTO   1CA
01C7:  MOVF   42,W
01C8:  MOVWF  77
01C9:  GOTO   1D6
01CA:  CLRF   77
01CB:  MOVLW  08
01CC:  MOVWF  44
01CD:  RLF    42,F
01CE:  RLF    77,F
01CF:  MOVF   43,W
01D0:  SUBWF  77,W
01D1:  BTFSC  03.0
01D2:  MOVWF  77
01D3:  RLF    78,F
01D4:  DECFSZ 44,F
01D5:  GOTO   1CD
01D6:  BCF    03.5
01D7:  RETURN
*
01F3:  BSF    03.5
01F4:  MOVF   33,W
01F5:  ANDLW  07
01F6:  MOVWF  77
01F7:  RRF    33,W
01F8:  MOVWF  78
01F9:  RRF    78,F
01FA:  RRF    78,F
01FB:  MOVLW  1F
01FC:  ANDWF  78,F
01FD:  MOVF   78,W
01FE:  ADDWF  35,W
01FF:  MOVWF  04
0200:  BCF    03.7
0201:  BTFSC  36.0
0202:  BSF    03.7
0203:  CLRF   78
0204:  INCF   78,F
0205:  INCF   77,F
0206:  GOTO   208
0207:  RLF    78,F
0208:  DECFSZ 77,F
0209:  GOTO   207
020A:  MOVF   34,F
020B:  BTFSC  03.2
020C:  GOTO   210
020D:  MOVF   78,W
020E:  IORWF  00,F
020F:  GOTO   213
0210:  COMF   78,F
0211:  MOVF   78,W
0212:  ANDWF  00,F
0213:  BCF    03.5
0214:  RETURN
0215:  BSF    03.5
0216:  MOVF   33,W
0217:  ANDLW  07
0218:  MOVWF  77
0219:  RRF    33,W
021A:  MOVWF  78
021B:  RRF    78,F
021C:  RRF    78,F
021D:  MOVLW  1F
021E:  ANDWF  78,F
021F:  MOVF   78,W
0220:  ADDWF  34,W
0221:  MOVWF  04
0222:  BCF    03.7
0223:  BTFSC  35.0
0224:  BSF    03.7
0225:  MOVF   00,W
0226:  MOVWF  78
0227:  INCF   77,F
0228:  GOTO   22A
0229:  RRF    78,F
022A:  DECFSZ 77,F
022B:  GOTO   229
022C:  BCF    03.5
022D:  BCF    0A.3
022E:  BCF    0A.4
022F:  GOTO   48D (RETURN)
0230:  BSF    03.5
0231:  CLRF   57
0232:  MOVF   04,W
0233:  MOVWF  56
0234:  BCF    57.0
0235:  BTFSC  03.7
0236:  BSF    57.0
0237:  SWAPF  50,W
0238:  IORLW  F0
0239:  MOVWF  52
023A:  ADDWF  52,F
023B:  ADDLW  E2
023C:  MOVWF  53
023D:  ADDLW  32
023E:  MOVWF  55
023F:  MOVF   50,W
0240:  ANDLW  0F
0241:  ADDWF  53,F
0242:  ADDWF  53,F
0243:  ADDWF  55,F
0244:  ADDLW  E9
0245:  MOVWF  54
0246:  ADDWF  54,F
0247:  ADDWF  54,F
0248:  SWAPF  4F,W
0249:  ANDLW  0F
024A:  ADDWF  54,F
024B:  ADDWF  55,F
024C:  RLF    54,F
024D:  RLF    55,F
024E:  COMF   55,F
024F:  RLF    55,F
0250:  MOVF   4F,W
0251:  ANDLW  0F
0252:  ADDWF  55,F
0253:  RLF    52,F
0254:  MOVLW  07
0255:  MOVWF  51
0256:  MOVLW  0A
0257:  ADDWF  55,F
0258:  DECF   54,F
0259:  BTFSS  03.0
025A:  GOTO   257
025B:  ADDWF  54,F
025C:  DECF   53,F
025D:  BTFSS  03.0
025E:  GOTO   25B
025F:  ADDWF  53,F
0260:  DECF   52,F
0261:  BTFSS  03.0
0262:  GOTO   25F
0263:  ADDWF  52,F
0264:  DECF   51,F
0265:  BTFSS  03.0
0266:  GOTO   263
0267:  MOVLW  D1
0268:  MOVWF  04
0269:  BCF    03.7
026A:  MOVLW  07
026B:  ANDWF  56,W
026C:  BCF    56.6
026D:  ADDWF  04,F
026E:  MOVLW  D5
026F:  SUBWF  04,W
0270:  BTFSC  03.2
0271:  BSF    56.6
0272:  MOVF   00,W
0273:  MOVWF  77
0274:  BTFSS  03.2
0275:  GOTO   27E
0276:  BTFSC  56.6
0277:  GOTO   27E
0278:  BTFSC  56.4
0279:  GOTO   29F
027A:  BTFSC  56.3
027B:  GOTO   27E
027C:  MOVLW  20
027D:  GOTO   281
027E:  BSF    56.3
027F:  BCF    56.4
0280:  MOVLW  30
0281:  ADDWF  77,F
0282:  CLRF   50
0283:  MOVF   04,W
0284:  MOVWF  4F
0285:  BCF    50.0
0286:  BTFSC  03.7
0287:  BSF    50.0
0288:  MOVF   77,W
0289:  MOVWF  58
028A:  BCF    03.5
028B:  MOVF   44,W
028C:  MOVWF  04
028D:  BCF    03.7
028E:  BTFSC  45.0
028F:  BSF    03.7
0290:  BSF    03.5
0291:  MOVF   58,W
0292:  MOVWF  00
0293:  INCF   04,F
0294:  CLRF   00
0295:  BCF    03.5
0296:  INCF   44,F
0297:  BTFSC  03.2
0298:  INCF   45,F
0299:  BSF    03.5
029A:  MOVF   4F,W
029B:  MOVWF  04
029C:  BCF    03.7
029D:  BTFSC  50.0
029E:  BSF    03.7
029F:  INCF   04,F
02A0:  BTFSS  56.6
02A1:  GOTO   26E
02A2:  BCF    03.5
02A3:  RETURN
*
0366:  MOVLW  10
0367:  BSF    03.5
0368:  MOVWF  44
0369:  CLRF   77
036A:  CLRF   7A
036B:  RRF    41,F
036C:  RRF    40,F
036D:  BTFSS  03.0
036E:  GOTO   375
036F:  MOVF   42,W
0370:  ADDWF  77,F
0371:  BTFSC  03.0
0372:  INCF   7A,F
0373:  MOVF   43,W
0374:  ADDWF  7A,F
0375:  RRF    7A,F
0376:  RRF    77,F
0377:  RRF    79,F
0378:  RRF    78,F
0379:  DECFSZ 44,F
037A:  GOTO   36B
037B:  BCF    03.5
037C:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03A3:  BCF    03.5
03A4:  CLRF   27
03A5:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
006B:  MOVLW  BA
006C:  MOVWF  04
006D:  BCF    03.7
006E:  MOVF   00,W
006F:  BTFSC  03.2
0070:  GOTO   07E
0071:  MOVLW  06
0072:  MOVWF  78
0073:  CLRF   77
0074:  DECFSZ 77,F
0075:  GOTO   074
0076:  DECFSZ 78,F
0077:  GOTO   073
0078:  MOVLW  7B
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  DECFSZ 00,F
007D:  GOTO   071
007E:  RETURN
*
00D8:  MOVLW  03
00D9:  BSF    03.5
00DA:  SUBWF  34,F
00DB:  BTFSS  03.0
00DC:  GOTO   0E7
00DD:  MOVLW  B4
00DE:  MOVWF  04
00DF:  BCF    03.7
00E0:  MOVF   00,W
00E1:  BTFSC  03.2
00E2:  GOTO   0E7
00E3:  GOTO   0E5
00E4:  GOTO   0E5
00E5:  DECFSZ 00,F
00E6:  GOTO   0E4
00E7:  BCF    03.5
00E8:  RETURN
....................  
.................... // I2C Configuration: I2C1 == Default pins and use Hardware Interrupts 
.................... #use i2c(MASTER, I2C1) 
*
0087:  BCF    03.5
0088:  BCF    14.7
0089:  BCF    0C.3
008A:  BSF    03.5
008B:  MOVF   5E,W
008C:  BCF    03.5
008D:  MOVWF  13
008E:  MOVLW  02
008F:  BTFSC  14.7
0090:  GOTO   098
0091:  BTFSS  0C.3
0092:  GOTO   091
0093:  MOVLW  00
0094:  BSF    03.5
0095:  BTFSC  11.6
0096:  MOVLW  01
0097:  BCF    03.5
0098:  MOVWF  78
*
00A1:  BCF    03.5
00A2:  BCF    14.7
00A3:  BCF    0C.3
00A4:  BSF    03.5
00A5:  MOVF   5E,W
00A6:  BCF    03.5
00A7:  MOVWF  13
00A8:  MOVLW  02
00A9:  BTFSC  14.7
00AA:  GOTO   0B2
00AB:  BTFSS  0C.3
00AC:  GOTO   0AB
00AD:  MOVLW  00
00AE:  BSF    03.5
00AF:  BTFSC  11.6
00B0:  MOVLW  01
00B1:  BCF    03.5
00B2:  MOVWF  78
....................  
.................... // Color cache to see what user typed 
.................... // 16 bit because user can type up to 999 
.................... uint16_t rgb_buffer[3] = {0, 0, 0}; 
*
03A6:  CLRF   2E
03A7:  CLRF   2F
03A8:  CLRF   30
03A9:  CLRF   31
03AA:  CLRF   32
03AB:  CLRF   33
....................  
.................... // Color to be writen on LED strip 
.................... uint16_t rgb_map[3] = {0, 0, 0}; 
03AC:  CLRF   34
03AD:  CLRF   35
03AE:  CLRF   36
03AF:  CLRF   37
03B0:  CLRF   38
03B1:  CLRF   39
....................  
.................... // Cursor reference to write on 16x2 
.................... // Assuming it is on 2nd row 
.................... uint8_t cursor_map[3] = {1, 6, 11}; 
03B2:  MOVLW  01
03B3:  MOVWF  3A
03B4:  MOVLW  06
03B5:  MOVWF  3B
03B6:  MOVLW  0B
03B7:  MOVWF  3C
....................  
.................... #include <16x2_pcf8574.c> 
.................... // flags for control 
.................... #define LCD_CLEARDISPLAY 0x01 
.................... #define LCD_RETURNHOME 0x02 
.................... #define LCD_ENTRYMODESET 0x04 
.................... #define LCD_DISPLAYCONTROL 0x08 
.................... #define LCD_CURSORSHIFT 0x10 
.................... #define LCD_FUNCTIONSET 0x20 
.................... #define LCD_SETCGRAMADDR 0x40 
.................... #define LCD_SETDDRAMADDR 0x80 
....................  
.................... // flags for display entry mode 
.................... #define LCD_ENTRYRIGHT 0x00 
.................... #define LCD_ENTRYLEFT 0x02 
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01 
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00 
....................  
....................  
.................... // flags for display on/off control 
.................... #define LCD_DISPLAYON 0x04 
.................... #define LCD_DISPLAYOFF 0x00 
.................... #define LCD_CURSORON 0x02 
.................... #define LCD_CURSOROFF 0x00 
.................... #define LCD_BLINKON 0x01 
.................... #define LCD_BLINKOFF 0x00 
....................  
.................... // flags for display/cursor shift 
.................... #define LCD_DISPLAYMOVE 0x08 
.................... #define LCD_CURSORMOVE 0x00 
.................... #define LCD_MOVERIGHT 0x04 
.................... #define LCD_MOVELEFT 0x00 
....................  
.................... // flags for function set 
.................... #define LCD_8BITMODE 0x10 
.................... #define LCD_4BITMODE 0x00 
.................... #define LCD_2LINE 0x08 
.................... #define LCD_1LINE 0x00 
.................... #define LCD_5x10DOTS 0x04 
.................... #define LCD_5x8DOTS 0x00 
....................  
.................... // flags for backlight control 
.................... #define LCD_BACKLIGHT 0x08 
.................... #define LCD_NOBACKLIGHT 0x00 
....................  
.................... // function flags 
.................... #define En 0b00000100  // Enable bit 
.................... #define Rw 0b00000010  // Read/Write bit 
....................  
.................... uint8_t _address; 
.................... uint8_t _backlightVal = LCD_BACKLIGHT; 
.................... uint8_t _displayControl; 
.................... uint8_t _displayFunction; 
.................... uint8_t _displayMode; 
.................... uint8_t _rows; 
.................... uint8_t _columns; 
....................  
.................... // sends code to pcf8574 so it redirects to the display 
.................... void expanderWrite(uint8_t _data) { 
....................    I2C_Start(); 
*
007F:  BSF    03.5
0080:  BSF    11.0
0081:  BTFSC  11.0
0082:  GOTO   081
....................    I2C_Write(_address); 
0083:  BCF    03.5
0084:  MOVF   3D,W
0085:  BSF    03.5
0086:  MOVWF  5E
....................    // Always write the backlight val 
....................    I2C_Write((int)(_data) | _backlightval); 
*
0099:  BSF    03.5
009A:  MOVF   5C,W
009B:  BCF    03.5
009C:  IORWF  3E,W
009D:  BSF    03.5
009E:  MOVWF  5D
009F:  MOVF   5D,W
00A0:  MOVWF  5E
....................    I2C_stop(); 
*
00B3:  BSF    03.5
00B4:  BSF    11.2
00B5:  BTFSC  11.2
00B6:  GOTO   0B5
00B7:  BCF    03.5
00B8:  RETURN
.................... } 
....................  
....................  
.................... // Pulse enable to write command 
.................... void pulseEnable(uint8_t _data) { 
....................    expanderWrite(_data | En); 
*
00C1:  MOVF   5A,W
00C2:  IORLW  04
00C3:  MOVWF  5B
00C4:  MOVWF  5C
00C5:  BCF    03.5
00C6:  CALL   07F
....................    delay_us(1); 
00C7:  GOTO   0C8
00C8:  GOTO   0C9
00C9:  NOP
....................     
....................    expanderWrite(_data & ~En); 
00CA:  BSF    03.5
00CB:  MOVF   5A,W
00CC:  ANDLW  FB
00CD:  MOVWF  5B
00CE:  MOVWF  5C
00CF:  BCF    03.5
00D0:  CALL   07F
....................    delay_us(50); 
00D1:  MOVLW  52
00D2:  MOVWF  77
00D3:  DECFSZ 77,F
00D4:  GOTO   0D3
00D5:  GOTO   0D6
00D6:  NOP
.................... } 
....................  
.................... // Send 4 bits to expander, than pulse enable 
.................... void write4bits(uint8_t value) { 
....................    expanderWrite(value); 
*
00B9:  BSF    03.5
00BA:  MOVF   59,W
00BB:  MOVWF  5C
00BC:  BCF    03.5
00BD:  CALL   07F
....................    pulseEnable(value); 
00BE:  BSF    03.5
00BF:  MOVF   59,W
00C0:  MOVWF  5A
*
00D7:  RETURN
.................... } 
....................  
.................... // Send 8 bits dividing in two nibbles 
.................... void send(uint8_t value, uint8_t mode) { 
*
00E9:  BSF    03.5
00EA:  MOVF   54,W
00EB:  ANDLW  F0
00EC:  MOVWF  56
00ED:  SWAPF  54,W
00EE:  MOVWF  77
00EF:  MOVLW  F0
00F0:  ANDWF  77,F
00F1:  MOVF   77,W
00F2:  ANDLW  F0
00F3:  MOVWF  57
....................    uint8_t MSB = value & 0b11110000; 
....................    uint8_t LSB = (value << 4) & 0b11110000; 
....................    write4bits((MSB)|mode); 
00F4:  MOVF   56,W
00F5:  IORWF  55,W
00F6:  MOVWF  58
00F7:  MOVWF  59
00F8:  BCF    03.5
00F9:  CALL   0B9
....................    write4bits((LSB)|mode); 
00FA:  BSF    03.5
00FB:  MOVF   57,W
00FC:  IORWF  55,W
00FD:  MOVWF  58
00FE:  MOVWF  59
00FF:  BCF    03.5
0100:  CALL   0B9
0101:  RETURN
.................... } 
....................  
.................... // Command uses RS = 0 
.................... void command(uint8_t value) { 
....................    send(value, 0b00000000); 
0102:  BSF    03.5
0103:  MOVF   43,W
0104:  MOVWF  54
0105:  CLRF   55
0106:  BCF    03.5
0107:  CALL   0E9
0108:  RETURN
.................... } 
....................  
.................... // Write uses RS = 1 
.................... int write(uint8_t value) { 
....................    send(value, 0b00000001); 
*
01B4:  MOVF   53,W
01B5:  MOVWF  54
01B6:  MOVLW  01
01B7:  MOVWF  55
01B8:  BCF    03.5
01B9:  CALL   0E9
....................    return 1; 
01BA:  MOVLW  01
01BB:  MOVWF  78
.................... } 
....................  
.................... // Change display configurations 
.................... void display() { 
....................    _displayControl |= LCD_DISPLAYON; 
*
0177:  BSF    3F.2
....................    command(LCD_DISPLAYCONTROL | _displayControl); 
0178:  MOVF   3F,W
0179:  IORLW  08
017A:  BSF    03.5
017B:  MOVWF  33
017C:  MOVWF  43
017D:  BCF    03.5
017E:  CALL   102
.................... } 
....................  
.................... // Clear display 
.................... void clear() { 
....................    command(LCD_CLEARDISPLAY); 
017F:  MOVLW  01
0180:  BSF    03.5
0181:  MOVWF  43
0182:  BCF    03.5
0183:  CALL   102
....................    delay_us(2000); 
0184:  MOVLW  02
0185:  BSF    03.5
0186:  MOVWF  3A
0187:  BCF    03.5
0188:  CALL   06B
.................... } 
....................  
.................... // Put cursor home 
.................... void home() { 
....................    command(LCD_RETURNHOME); 
*
0192:  MOVLW  02
0193:  BSF    03.5
0194:  MOVWF  43
0195:  BCF    03.5
0196:  CALL   102
....................    delay_us(2000); 
0197:  MOVLW  02
0198:  BSF    03.5
0199:  MOVWF  3A
019A:  BCF    03.5
019B:  CALL   06B
.................... } 
....................  
.................... // Put cursor on specified column/row 
.................... // PS: Rows and Columns start with 0 
.................... void setCursor(uint8_t col, uint8_t row){ 
....................    int row_offsets[] = { 0x00, 0x40 }; 
*
01D8:  BSF    03.5
01D9:  CLRF   40
01DA:  MOVLW  40
01DB:  MOVWF  41
....................    row = (row%_rows);     
01DC:  MOVF   3F,W
01DD:  MOVWF  42
01DE:  BCF    03.5
01DF:  MOVF   42,W
01E0:  BSF    03.5
01E1:  MOVWF  43
01E2:  BCF    03.5
01E3:  CALL   1C1
01E4:  MOVF   77,W
01E5:  BSF    03.5
01E6:  MOVWF  3F
....................    command(LCD_SETDDRAMADDR | (col + row_offsets[row])); 
01E7:  MOVLW  C0
01E8:  ADDWF  3F,W
01E9:  MOVWF  04
01EA:  BCF    03.7
01EB:  MOVF   00,W
01EC:  ADDWF  3E,W
01ED:  IORLW  80
01EE:  MOVWF  42
01EF:  MOVWF  43
01F0:  BCF    03.5
01F1:  CALL   102
01F2:  RETURN
.................... } 
....................  
....................  
.................... // Write an array of chars 
.................... void printstr(char *c[]) { 
*
019F:  BSF    03.5
01A0:  CLRF   51
....................    int i = 0; 
....................    while (c[i]) { 
01A1:  MOVF   51,W
01A2:  ADDWF  4F,W
01A3:  MOVWF  04
01A4:  BCF    03.7
01A5:  BTFSC  50.0
01A6:  BSF    03.7
01A7:  MOVF   00,F
01A8:  BTFSC  03.2
01A9:  GOTO   1BF
....................       write(c[i]); 
01AA:  MOVF   51,W
01AB:  ADDWF  4F,W
01AC:  MOVWF  04
01AD:  BCF    03.7
01AE:  BTFSC  50.0
01AF:  BSF    03.7
01B0:  MOVF   00,W
01B1:  MOVWF  52
01B2:  MOVF   52,W
01B3:  MOVWF  53
....................       i++; 
*
01BC:  BSF    03.5
01BD:  INCF   51,F
01BE:  GOTO   1A1
....................    } 
01BF:  BCF    03.5
01C0:  RETURN
.................... } 
....................  
.................... // print single int 
.................... void printint(uint16_t d) { 
....................     char c[16]; 
....................     sprintf(c, "%lu", d); 
*
05D6:  BCF    03.5
05D7:  CLRF   45
05D8:  MOVLW  B7
05D9:  MOVWF  44
05DA:  MOVLW  10
05DB:  MOVWF  04
05DC:  BSF    03.5
05DD:  MOVF   36,W
05DE:  MOVWF  50
05DF:  MOVF   35,W
05E0:  MOVWF  4F
05E1:  BCF    03.5
05E2:  CALL   230
....................     printstr(c); 
05E3:  BSF    03.5
05E4:  CLRF   50
05E5:  MOVLW  B7
05E6:  MOVWF  4F
05E7:  BCF    03.5
05E8:  CALL   19F
.................... } 
....................  
.................... // print long in form 00X -> XXX 
.................... void printlong(uint16_t d) { 
....................     char c[16]; 
....................     sprintf(c, "%03lu", d); 
*
02B6:  BCF    03.5
02B7:  CLRF   45
02B8:  MOVLW  BF
02B9:  MOVWF  44
02BA:  MOVLW  0A
02BB:  MOVWF  04
02BC:  BSF    03.5
02BD:  MOVF   3E,W
02BE:  MOVWF  50
02BF:  MOVF   3D,W
02C0:  MOVWF  4F
02C1:  BCF    03.5
02C2:  CALL   230
....................     printstr(c); 
02C3:  BSF    03.5
02C4:  CLRF   50
02C5:  MOVLW  BF
02C6:  MOVWF  4F
02C7:  BCF    03.5
02C8:  CALL   19F
.................... } 
....................  
.................... // Automatic display configuration 
.................... void initializeLCD(uint8_t address, uint8_t columns, uint8_t rows) { 
....................    _address = address; 
*
0109:  BSF    03.5
010A:  MOVF   30,W
010B:  BCF    03.5
010C:  MOVWF  3D
....................    _columns = columns; 
010D:  BSF    03.5
010E:  MOVF   31,W
010F:  BCF    03.5
0110:  MOVWF  43
....................    _rows = rows; 
0111:  BSF    03.5
0112:  MOVF   32,W
0113:  BCF    03.5
0114:  MOVWF  42
....................     
....................    _displayFunction = LCD_4BITMODE | LCD_2LINE | LCD_5x8DOTS; 
0115:  MOVLW  08
0116:  MOVWF  40
....................    delay_ms(500); 
0117:  MOVLW  02
0118:  BSF    03.5
0119:  MOVWF  33
011A:  MOVLW  FA
011B:  MOVWF  3A
011C:  BCF    03.5
011D:  CALL   06B
011E:  BSF    03.5
011F:  DECFSZ 33,F
0120:  GOTO   11A
....................    expanderWrite(_backlightval); 
0121:  BCF    03.5
0122:  MOVF   3E,W
0123:  BSF    03.5
0124:  MOVWF  5C
0125:  BCF    03.5
0126:  CALL   07F
....................    delay_ms(1000); 
0127:  MOVLW  04
0128:  BSF    03.5
0129:  MOVWF  33
012A:  MOVLW  FA
012B:  MOVWF  3A
012C:  BCF    03.5
012D:  CALL   06B
012E:  BSF    03.5
012F:  DECFSZ 33,F
0130:  GOTO   12A
....................     
....................    write4bits(0x03 << 4); 
0131:  MOVLW  30
0132:  MOVWF  59
0133:  BCF    03.5
0134:  CALL   0B9
....................    delay_us(4500); 
0135:  MOVLW  04
0136:  BSF    03.5
0137:  MOVWF  3A
0138:  BCF    03.5
0139:  CALL   06B
013A:  MOVLW  02
013B:  BSF    03.5
013C:  MOVWF  33
013D:  MOVLW  F9
013E:  MOVWF  34
013F:  BCF    03.5
0140:  CALL   0D8
0141:  BSF    03.5
0142:  DECFSZ 33,F
0143:  GOTO   13D
....................     
....................    write4bits(0x03 << 4); 
0144:  MOVLW  30
0145:  MOVWF  59
0146:  BCF    03.5
0147:  CALL   0B9
....................    delay_us(4500); 
0148:  MOVLW  04
0149:  BSF    03.5
014A:  MOVWF  3A
014B:  BCF    03.5
014C:  CALL   06B
014D:  MOVLW  02
014E:  BSF    03.5
014F:  MOVWF  33
0150:  MOVLW  F9
0151:  MOVWF  34
0152:  BCF    03.5
0153:  CALL   0D8
0154:  BSF    03.5
0155:  DECFSZ 33,F
0156:  GOTO   150
....................     
....................    write4bits(0x03 << 4); 
0157:  MOVLW  30
0158:  MOVWF  59
0159:  BCF    03.5
015A:  CALL   0B9
....................    delay_us(1500); 
015B:  MOVLW  01
015C:  BSF    03.5
015D:  MOVWF  3A
015E:  BCF    03.5
015F:  CALL   06B
0160:  MOVLW  02
0161:  BSF    03.5
0162:  MOVWF  33
0163:  MOVLW  F9
0164:  MOVWF  34
0165:  BCF    03.5
0166:  CALL   0D8
0167:  BSF    03.5
0168:  DECFSZ 33,F
0169:  GOTO   163
....................     
....................    write4bits(0x02 << 4); 
016A:  MOVLW  20
016B:  MOVWF  59
016C:  BCF    03.5
016D:  CALL   0B9
....................     
....................    command(LCD_FUNCTIONSET | _displayFunction); 
016E:  MOVF   40,W
016F:  IORLW  20
0170:  BSF    03.5
0171:  MOVWF  33
0172:  MOVWF  43
0173:  BCF    03.5
0174:  CALL   102
....................     
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSORON | LCD_BLINKON; 
0175:  MOVLW  07
0176:  MOVWF  3F
....................     
....................    display(); 
....................     
....................    clear(); 
....................     
....................    _displayMode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT; 
*
0189:  MOVLW  02
018A:  MOVWF  41
....................     
....................    command(LCD_ENTRYMODESET | _displayMode); 
018B:  MOVF   41,W
018C:  IORLW  04
018D:  BSF    03.5
018E:  MOVWF  33
018F:  MOVWF  43
0190:  BCF    03.5
0191:  CALL   102
....................     
....................    home(); 
*
019C:  BCF    0A.3
019D:  BCF    0A.4
019E:  GOTO   3F1 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include <4x4_keyboard.c> 
.................... // Define pin references 
.................... #define LINHA0 PIN_B7 
.................... #define LINHA1 PIN_B6 
.................... #define LINHA2 PIN_B5 
.................... #define LINHA3 PIN_B4 
.................... #define COLUN0 PIN_B3 
.................... #define COLUN1 PIN_B2 
.................... #define COLUN2 PIN_B1 
.................... #define COLUN3 PIN_B0 
....................  
.................... // 4x4 keyboard matrix 
.................... uint8_t linhas[4] = {LINHA0, LINHA1, LINHA2, LINHA3}; 
*
03B8:  MOVLW  37
03B9:  MOVWF  46
03BA:  MOVLW  36
03BB:  MOVWF  47
03BC:  MOVLW  35
03BD:  MOVWF  48
03BE:  MOVLW  34
03BF:  MOVWF  49
.................... uint8_t colunas[4] = {COLUN0, COLUN1, COLUN2, COLUN3}; 
03C0:  MOVLW  33
03C1:  MOVWF  4A
03C2:  MOVLW  32
03C3:  MOVWF  4B
03C4:  MOVLW  31
03C5:  MOVWF  4C
03C6:  MOVLW  30
03C7:  MOVWF  4D
....................  
.................... // 4x4 keyboard map 
.................... char input_array[4][4] = {{'1','2','3','A'},{'4','5','6','B'},{'7','8','9','C',},{'*','0','#','D'}}; 
03C8:  MOVLW  31
03C9:  MOVWF  4E
03CA:  MOVLW  32
03CB:  MOVWF  4F
03CC:  MOVLW  33
03CD:  MOVWF  50
03CE:  MOVLW  41
03CF:  MOVWF  51
03D0:  MOVLW  34
03D1:  MOVWF  52
03D2:  MOVLW  35
03D3:  MOVWF  53
03D4:  MOVLW  36
03D5:  MOVWF  54
03D6:  MOVLW  42
03D7:  MOVWF  55
03D8:  MOVLW  37
03D9:  MOVWF  56
03DA:  MOVLW  38
03DB:  MOVWF  57
03DC:  MOVLW  39
03DD:  MOVWF  58
03DE:  MOVLW  43
03DF:  MOVWF  59
03E0:  MOVLW  2A
03E1:  MOVWF  5A
03E2:  MOVLW  30
03E3:  MOVWF  5B
03E4:  MOVLW  23
03E5:  MOVWF  5C
03E6:  MOVLW  44
03E7:  MOVWF  5D
....................  
.................... // Cursor position is controled mannually  
.................... uint8_t pos_cursor = 0; 
....................  
.................... // Color being edited: 0 => red; 1 => green; 2 => blue 
.................... uint8_t color_selected = 0; 
....................  
.................... // import the whole math.h uses many resources. Prefered to only implement ipow 
.................... int ipow(uint16_t base, uint16_t exp) 
*
0618:  CLRF   3F
0619:  MOVLW  01
061A:  MOVWF  3E
.................... { 
....................     uint16_t result = 1; 
....................     for (;;) 
....................     { 
....................         if (exp & 1) 
061B:  MOVF   3C,W
061C:  ANDLW  01
061D:  MOVWF  77
061E:  CLRF   7A
061F:  MOVF   77,W
0620:  IORWF  7A,W
0621:  BTFSC  03.2
0622:  GOTO   632
....................             result *= base; 
0623:  MOVF   3F,W
0624:  MOVWF  41
0625:  MOVF   3E,W
0626:  MOVWF  40
0627:  MOVF   3B,W
0628:  MOVWF  43
0629:  MOVF   3A,W
062A:  MOVWF  42
062B:  BCF    03.5
062C:  CALL   366
062D:  MOVF   79,W
062E:  BSF    03.5
062F:  MOVWF  3F
0630:  MOVF   78,W
0631:  MOVWF  3E
....................         exp >>= 1; 
0632:  BCF    03.0
0633:  RRF    3D,F
0634:  RRF    3C,F
....................         if (!exp) 
0635:  MOVF   3C,W
0636:  IORWF  3D,W
0637:  BTFSC  03.2
....................             break; 
0638:  GOTO   649
....................         base *= base; 
0639:  MOVF   3B,W
063A:  MOVWF  41
063B:  MOVF   3A,W
063C:  MOVWF  40
063D:  MOVF   3B,W
063E:  MOVWF  43
063F:  MOVF   3A,W
0640:  MOVWF  42
0641:  BCF    03.5
0642:  CALL   366
0643:  MOVF   79,W
0644:  BSF    03.5
0645:  MOVWF  3B
0646:  MOVF   78,W
0647:  MOVWF  3A
0648:  GOTO   61B
....................     } 
....................  
....................     return result; 
0649:  MOVF   3E,W
064A:  MOVWF  78
.................... } 
....................  
....................  
.................... // write the current color on display 
.................... void write_color(uint16_t color) { 
....................    pos_cursor = 0; 
*
02A4:  CLRF   5E
....................    setCursor(cursor_map[color_selected], 1); 
02A5:  MOVLW  3A
02A6:  ADDWF  5F,W
02A7:  MOVWF  04
02A8:  BCF    03.7
02A9:  MOVF   00,W
02AA:  BSF    03.5
02AB:  MOVWF  3D
02AC:  MOVWF  3E
02AD:  MOVLW  01
02AE:  MOVWF  3F
02AF:  BCF    03.5
02B0:  CALL   1D8
....................    printlong(color);   
02B1:  BSF    03.5
02B2:  MOVF   3C,W
02B3:  MOVWF  3E
02B4:  MOVF   3B,W
02B5:  MOVWF  3D
....................    setCursor(cursor_map[color_selected], 1); 
*
02C9:  MOVLW  3A
02CA:  ADDWF  5F,W
02CB:  MOVWF  04
02CC:  BCF    03.7
02CD:  MOVF   00,W
02CE:  BSF    03.5
02CF:  MOVWF  3D
02D0:  MOVWF  3E
02D1:  MOVLW  01
02D2:  MOVWF  3F
02D3:  BCF    03.5
02D4:  CALL   1D8
....................    rgb_buffer[color_selected] = rgb_map[color_selected]; 
02D5:  BCF    03.0
02D6:  RLF    5F,W
02D7:  ADDLW  2E
02D8:  MOVWF  78
02D9:  CLRF   7A
02DA:  BTFSC  03.0
02DB:  INCF   7A,F
02DC:  MOVF   78,W
02DD:  BSF    03.5
02DE:  MOVWF  3D
02DF:  MOVF   7A,W
02E0:  MOVWF  3E
02E1:  BCF    03.0
02E2:  BCF    03.5
02E3:  RLF    5F,W
02E4:  ADDLW  34
02E5:  MOVWF  04
02E6:  BCF    03.7
02E7:  INCF   04,F
02E8:  MOVF   00,W
02E9:  MOVWF  7A
02EA:  DECF   04,F
02EB:  MOVF   00,W
02EC:  BSF    03.5
02ED:  MOVWF  3F
02EE:  MOVF   7A,W
02EF:  MOVWF  40
02F0:  MOVF   3D,W
02F1:  MOVWF  04
02F2:  BCF    03.7
02F3:  BTFSC  3E.0
02F4:  BSF    03.7
02F5:  INCF   04,F
02F6:  MOVF   40,W
02F7:  MOVWF  00
02F8:  DECF   04,F
02F9:  MOVF   3F,W
02FA:  MOVWF  00
02FB:  BCF    03.5
02FC:  RETURN
.................... } 
....................  
.................... // show error mesage (when color > 255) 
.................... void showErr() { 
....................    rgb_buffer[color_selected] = rgb_map[color_selected]; 
02FD:  BCF    03.0
02FE:  RLF    5F,W
02FF:  ADDLW  2E
0300:  MOVWF  78
0301:  CLRF   7A
0302:  BTFSC  03.0
0303:  INCF   7A,F
0304:  MOVF   78,W
0305:  BSF    03.5
0306:  MOVWF  39
0307:  MOVF   7A,W
0308:  MOVWF  3A
0309:  BCF    03.0
030A:  BCF    03.5
030B:  RLF    5F,W
030C:  ADDLW  34
030D:  MOVWF  04
030E:  BCF    03.7
030F:  INCF   04,F
0310:  MOVF   00,W
0311:  MOVWF  7A
0312:  DECF   04,F
0313:  MOVF   00,W
0314:  BSF    03.5
0315:  MOVWF  3B
0316:  MOVF   7A,W
0317:  MOVWF  3C
0318:  MOVF   39,W
0319:  MOVWF  04
031A:  BCF    03.7
031B:  BTFSC  3A.0
031C:  BSF    03.7
031D:  INCF   04,F
031E:  MOVF   3C,W
031F:  MOVWF  00
0320:  DECF   04,F
0321:  MOVF   3B,W
0322:  MOVWF  00
....................     
....................    setCursor(cursor_map[color_selected], 1); 
0323:  MOVLW  3A
0324:  BCF    03.5
0325:  ADDWF  5F,W
0326:  MOVWF  04
0327:  BCF    03.7
0328:  MOVF   00,W
0329:  BSF    03.5
032A:  MOVWF  39
032B:  MOVWF  3E
032C:  MOVLW  01
032D:  MOVWF  3F
032E:  BCF    03.5
032F:  CALL   1D8
....................    char error_msg[4] = "ERR"; 
0330:  MOVLW  45
0331:  BSF    03.5
0332:  MOVWF  35
0333:  MOVLW  52
0334:  MOVWF  36
0335:  MOVWF  37
0336:  CLRF   38
....................    printstr(error_msg); 
0337:  CLRF   50
0338:  MOVLW  B5
0339:  MOVWF  4F
033A:  BCF    03.5
033B:  CALL   19F
....................     
....................    setCursor(cursor_map[color_selected], 1); 
033C:  MOVLW  3A
033D:  ADDWF  5F,W
033E:  MOVWF  04
033F:  BCF    03.7
0340:  MOVF   00,W
0341:  BSF    03.5
0342:  MOVWF  39
0343:  MOVWF  3E
0344:  MOVLW  01
0345:  MOVWF  3F
0346:  BCF    03.5
0347:  CALL   1D8
....................    delay_ms(500); 
0348:  MOVLW  02
0349:  BSF    03.5
034A:  MOVWF  39
034B:  MOVLW  FA
034C:  MOVWF  3A
034D:  BCF    03.5
034E:  CALL   06B
034F:  BSF    03.5
0350:  DECFSZ 39,F
0351:  GOTO   34B
....................  
....................    write_color(rgb_map[color_selected]); 
0352:  BCF    03.0
0353:  BCF    03.5
0354:  RLF    5F,W
0355:  ADDLW  34
0356:  MOVWF  04
0357:  BCF    03.7
0358:  INCF   04,F
0359:  MOVF   00,W
035A:  BSF    03.5
035B:  MOVWF  3A
035C:  DECF   04,F
035D:  MOVF   00,W
035E:  MOVWF  39
035F:  MOVF   3A,W
0360:  MOVWF  3C
0361:  MOVF   39,W
0362:  MOVWF  3B
0363:  BCF    03.5
0364:  CALL   2A4
0365:  RETURN
.................... } 
....................  
....................  
.................... // deal with user input 
.................... void user_input(uint16_t digited) { 
....................    // convert from ascii to int 
....................    digited = digited - 48; 
*
049F:  MOVLW  30
04A0:  SUBWF  33,F
04A1:  MOVLW  00
04A2:  BTFSS  03.0
04A3:  MOVLW  01
04A4:  SUBWF  34,F
....................   
....................    // if * 
....................    if (digited == 65530) { 
04A5:  MOVF   33,W
04A6:  SUBLW  FA
04A7:  BTFSS  03.2
04A8:  GOTO   4DF
04A9:  INCFSZ 34,W
04AA:  GOTO   4DF
....................       if (rgb_map[color_selected] > 0) { 
04AB:  BCF    03.0
04AC:  BCF    03.5
04AD:  RLF    5F,W
04AE:  ADDLW  34
04AF:  MOVWF  04
04B0:  BCF    03.7
04B1:  INCF   04,F
04B2:  MOVF   00,W
04B3:  BSF    03.5
04B4:  MOVWF  36
04B5:  DECF   04,F
04B6:  MOVF   00,W
04B7:  MOVWF  35
04B8:  MOVF   35,F
04B9:  BTFSS  03.2
04BA:  GOTO   4BE
04BB:  MOVF   36,F
04BC:  BTFSC  03.2
04BD:  GOTO   4DE
....................          // decrease 
....................          write_color(--rgb_map[color_selected]); 
04BE:  BCF    03.0
04BF:  BCF    03.5
04C0:  RLF    5F,W
04C1:  ADDLW  34
04C2:  MOVWF  04
04C3:  BCF    03.7
04C4:  MOVLW  FF
04C5:  ADDWF  00,F
04C6:  BTFSC  03.0
04C7:  GOTO   4CB
04C8:  INCF   04,F
04C9:  DECF   00,F
04CA:  DECF   04,F
04CB:  INCF   04,F
04CC:  MOVF   00,W
04CD:  BSF    03.5
04CE:  MOVWF  36
04CF:  DECF   04,F
04D0:  MOVF   00,W
04D1:  MOVWF  35
04D2:  MOVF   36,W
04D3:  MOVWF  3C
04D4:  MOVF   35,W
04D5:  MOVWF  3B
04D6:  BCF    03.5
04D7:  CALL   2A4
....................          delay_ms(40); 
04D8:  MOVLW  28
04D9:  BSF    03.5
04DA:  MOVWF  3A
04DB:  BCF    03.5
04DC:  CALL   06B
04DD:  BSF    03.5
....................       }        
....................    } 
04DE:  GOTO   6CB
....................     
....................    // if # 
....................    else if (digited == 65523) { 
04DF:  MOVF   33,W
04E0:  SUBLW  F3
04E1:  BTFSS  03.2
04E2:  GOTO   51A
04E3:  INCFSZ 34,W
04E4:  GOTO   51A
....................        if (rgb_map[color_selected] < 255) { 
04E5:  BCF    03.0
04E6:  BCF    03.5
04E7:  RLF    5F,W
04E8:  ADDLW  34
04E9:  MOVWF  04
04EA:  BCF    03.7
04EB:  INCF   04,F
04EC:  MOVF   00,W
04ED:  BSF    03.5
04EE:  MOVWF  36
04EF:  DECF   04,F
04F0:  MOVF   00,W
04F1:  MOVWF  35
04F2:  MOVF   36,F
04F3:  BTFSS  03.2
04F4:  GOTO   519
04F5:  MOVF   35,W
04F6:  SUBLW  FE
04F7:  BTFSS  03.0
04F8:  GOTO   519
....................          // increase 
....................          write_color(++rgb_map[color_selected]); 
04F9:  BCF    03.0
04FA:  BCF    03.5
04FB:  RLF    5F,W
04FC:  ADDLW  34
04FD:  MOVWF  04
04FE:  BCF    03.7
04FF:  MOVLW  01
0500:  ADDWF  00,F
0501:  BTFSS  03.0
0502:  GOTO   506
0503:  INCF   04,F
0504:  INCF   00,F
0505:  DECF   04,F
0506:  INCF   04,F
0507:  MOVF   00,W
0508:  BSF    03.5
0509:  MOVWF  36
050A:  DECF   04,F
050B:  MOVF   00,W
050C:  MOVWF  35
050D:  MOVF   36,W
050E:  MOVWF  3C
050F:  MOVF   35,W
0510:  MOVWF  3B
0511:  BCF    03.5
0512:  CALL   2A4
....................          delay_ms(40); 
0513:  MOVLW  28
0514:  BSF    03.5
0515:  MOVWF  3A
0516:  BCF    03.5
0517:  CALL   06B
0518:  BSF    03.5
....................       }        
....................    } 
0519:  GOTO   6CB
....................     
....................    // if A -> C 
....................    else if (digited >= 17 && digited <=19) { 
051A:  MOVF   34,F
051B:  BTFSS  03.2
051C:  GOTO   521
051D:  MOVF   33,W
051E:  SUBLW  10
051F:  BTFSC  03.0
0520:  GOTO   576
0521:  MOVF   34,F
0522:  BTFSS  03.2
0523:  GOTO   576
0524:  MOVF   33,W
0525:  SUBLW  13
0526:  BTFSS  03.0
0527:  GOTO   576
....................       if(rgb_buffer[color_selected] <= 255) { 
0528:  BCF    03.0
0529:  BCF    03.5
052A:  RLF    5F,W
052B:  ADDLW  2E
052C:  MOVWF  04
052D:  BCF    03.7
052E:  INCF   04,F
052F:  MOVF   00,W
0530:  BSF    03.5
0531:  MOVWF  36
0532:  DECF   04,F
0533:  MOVF   00,W
0534:  MOVWF  35
0535:  MOVF   36,W
0536:  SUBLW  00
0537:  BTFSS  03.0
0538:  GOTO   572
....................          rgb_map[color_selected] = rgb_buffer[color_selected]; 
0539:  BCF    03.0
053A:  BCF    03.5
053B:  RLF    5F,W
053C:  ADDLW  34
053D:  MOVWF  78
053E:  CLRF   7A
053F:  BTFSC  03.0
0540:  INCF   7A,F
0541:  MOVF   78,W
0542:  BSF    03.5
0543:  MOVWF  35
0544:  MOVF   7A,W
0545:  MOVWF  36
0546:  BCF    03.0
0547:  BCF    03.5
0548:  RLF    5F,W
0549:  ADDLW  2E
054A:  MOVWF  04
054B:  BCF    03.7
054C:  INCF   04,F
054D:  MOVF   00,W
054E:  MOVWF  7A
054F:  DECF   04,F
0550:  MOVF   00,W
0551:  BSF    03.5
0552:  MOVWF  37
0553:  MOVF   7A,W
0554:  MOVWF  38
0555:  MOVF   35,W
0556:  MOVWF  04
0557:  BCF    03.7
0558:  BTFSC  36.0
0559:  BSF    03.7
055A:  INCF   04,F
055B:  MOVF   38,W
055C:  MOVWF  00
055D:  DECF   04,F
055E:  MOVF   37,W
055F:  MOVWF  00
....................          // go to digited -17 (color 0, 1 or 2) 
....................          color_selected = (digited-17); 
0560:  MOVLW  11
0561:  SUBWF  33,W
0562:  BCF    03.5
0563:  MOVWF  5F
....................          setCursor(cursor_map[color_selected], 1); 
0564:  MOVLW  3A
0565:  ADDWF  5F,W
0566:  MOVWF  04
0567:  BCF    03.7
0568:  MOVF   00,W
0569:  BSF    03.5
056A:  MOVWF  35
056B:  MOVWF  3E
056C:  MOVLW  01
056D:  MOVWF  3F
056E:  BCF    03.5
056F:  CALL   1D8
....................       } else { 
0570:  GOTO   574
0571:  BSF    03.5
....................          showErr();    
0572:  BCF    03.5
0573:  CALL   2FD
....................       } 
....................    } 
0574:  GOTO   6CA
0575:  BSF    03.5
....................     
....................    // if D 
....................    else if (digited == 20) { 
0576:  MOVF   33,W
0577:  SUBLW  14
0578:  BTFSS  03.2
0579:  GOTO   5D2
057A:  MOVF   34,F
057B:  BTFSS  03.2
057C:  GOTO   5D2
....................       // clean everybody 
....................       for (color_selected = 0; color_selected < 3; color_selected++) { 
057D:  BCF    03.5
057E:  CLRF   5F
057F:  MOVF   5F,W
0580:  SUBLW  02
0581:  BTFSS  03.0
0582:  GOTO   5BE
....................          rgb_buffer[color_selected] = rgb_map[color_selected] = 0; 
0583:  BCF    03.0
0584:  RLF    5F,W
0585:  ADDLW  2E
0586:  MOVWF  78
0587:  CLRF   7A
0588:  BTFSC  03.0
0589:  INCF   7A,F
058A:  MOVF   78,W
058B:  BSF    03.5
058C:  MOVWF  35
058D:  MOVF   7A,W
058E:  MOVWF  36
058F:  BCF    03.0
0590:  BCF    03.5
0591:  RLF    5F,W
0592:  ADDLW  34
0593:  MOVWF  04
0594:  BCF    03.7
0595:  INCF   04,F
0596:  CLRF   00
0597:  DECF   04,F
0598:  CLRF   00
0599:  MOVLW  00
059A:  BSF    03.5
059B:  MOVWF  37
059C:  MOVF   7A,W
059D:  MOVWF  38
059E:  MOVF   35,W
059F:  MOVWF  04
05A0:  BCF    03.7
05A1:  BTFSC  36.0
05A2:  BSF    03.7
05A3:  INCF   04,F
05A4:  MOVF   38,W
05A5:  MOVWF  00
05A6:  DECF   04,F
05A7:  MOVF   37,W
05A8:  MOVWF  00
....................          write_color(rgb_map[color_selected]); 
05A9:  BCF    03.0
05AA:  BCF    03.5
05AB:  RLF    5F,W
05AC:  ADDLW  34
05AD:  MOVWF  04
05AE:  BCF    03.7
05AF:  INCF   04,F
05B0:  MOVF   00,W
05B1:  BSF    03.5
05B2:  MOVWF  36
05B3:  DECF   04,F
05B4:  MOVF   00,W
05B5:  MOVWF  35
05B6:  MOVF   36,W
05B7:  MOVWF  3C
05B8:  MOVF   35,W
05B9:  MOVWF  3B
05BA:  BCF    03.5
05BB:  CALL   2A4
05BC:  INCF   5F,F
05BD:  GOTO   57F
....................       } 
....................        
....................       delay_ms(100); 
05BE:  MOVLW  64
05BF:  BSF    03.5
05C0:  MOVWF  3A
05C1:  BCF    03.5
05C2:  CALL   06B
....................        
....................       // go to color 0 
....................       color_selected = 0; 
05C3:  CLRF   5F
....................       setCursor(cursor_map[color_selected], 1); 
05C4:  MOVLW  3A
05C5:  ADDWF  5F,W
05C6:  MOVWF  04
05C7:  BCF    03.7
05C8:  MOVF   00,W
05C9:  BSF    03.5
05CA:  MOVWF  35
05CB:  MOVWF  3E
05CC:  MOVLW  01
05CD:  MOVWF  3F
05CE:  BCF    03.5
05CF:  CALL   1D8
....................    } 
05D0:  GOTO   6CA
05D1:  BSF    03.5
....................     
....................    // if 0-9, should type 
....................    else { 
....................       printint(digited); 
05D2:  MOVF   34,W
05D3:  MOVWF  36
05D4:  MOVF   33,W
05D5:  MOVWF  35
....................        
....................       // reset buffer if is char 0 
....................       if (pos_cursor==0) rgb_buffer[color_selected] = 0; 
*
05E9:  MOVF   5E,F
05EA:  BTFSS  03.2
05EB:  GOTO   5F5
05EC:  BCF    03.0
05ED:  RLF    5F,W
05EE:  ADDLW  2E
05EF:  MOVWF  04
05F0:  BCF    03.7
05F1:  INCF   04,F
05F2:  CLRF   00
05F3:  DECF   04,F
05F4:  CLRF   00
....................        
....................       // decimal multiplier 
....................       rgb_buffer[color_selected] += digited*ipow(10, 2-pos_cursor++); 
05F5:  BCF    03.0
05F6:  RLF    5F,W
05F7:  ADDLW  2E
05F8:  MOVWF  78
05F9:  CLRF   7A
05FA:  BTFSC  03.0
05FB:  INCF   7A,F
05FC:  MOVF   78,W
05FD:  BSF    03.5
05FE:  MOVWF  35
05FF:  MOVF   7A,W
0600:  MOVWF  36
0601:  MOVF   35,W
0602:  MOVWF  04
0603:  BCF    03.7
0604:  BTFSC  36.0
0605:  BSF    03.7
0606:  INCF   04,F
0607:  MOVF   00,W
0608:  MOVWF  38
0609:  DECF   04,F
060A:  MOVF   00,W
060B:  MOVWF  37
060C:  BCF    03.5
060D:  MOVF   5E,W
060E:  INCF   5E,F
060F:  SUBLW  02
0610:  BSF    03.5
0611:  MOVWF  39
0612:  CLRF   3B
0613:  MOVLW  0A
0614:  MOVWF  3A
0615:  CLRF   3D
0616:  MOVF   39,W
0617:  MOVWF  3C
*
064B:  MOVF   34,W
064C:  MOVWF  41
064D:  MOVF   33,W
064E:  MOVWF  40
064F:  CLRF   43
0650:  MOVF   78,W
0651:  MOVWF  42
0652:  BCF    03.5
0653:  CALL   366
0654:  MOVF   79,W
0655:  MOVWF  7A
0656:  MOVF   78,W
0657:  BSF    03.5
0658:  ADDWF  37,W
0659:  MOVWF  78
065A:  MOVF   38,W
065B:  BTFSC  03.0
065C:  INCFSZ 38,W
065D:  ADDWF  7A,F
065E:  MOVF   78,W
065F:  MOVWF  37
0660:  MOVF   7A,W
0661:  MOVWF  38
0662:  MOVF   35,W
0663:  MOVWF  04
0664:  BCF    03.7
0665:  BTFSC  36.0
0666:  BSF    03.7
0667:  INCF   04,F
0668:  MOVF   38,W
0669:  MOVWF  00
066A:  DECF   04,F
066B:  MOVF   37,W
066C:  MOVWF  00
....................        
....................       // if is the 3rd char, go to next color 
....................       if (pos_cursor > 2) { 
066D:  BCF    03.5
066E:  MOVF   5E,W
066F:  SUBLW  02
0670:  BTFSC  03.0
0671:  GOTO   6C5
....................          if(rgb_buffer[color_selected] <= 255) { 
0672:  BCF    03.0
0673:  RLF    5F,W
0674:  ADDLW  2E
0675:  MOVWF  04
0676:  BCF    03.7
0677:  INCF   04,F
0678:  MOVF   00,W
0679:  BSF    03.5
067A:  MOVWF  36
067B:  DECF   04,F
067C:  MOVF   00,W
067D:  MOVWF  35
067E:  MOVF   36,W
067F:  SUBLW  00
0680:  BTFSS  03.0
0681:  GOTO   6C3
....................             pos_cursor = 0; 
0682:  BCF    03.5
0683:  CLRF   5E
....................             rgb_map[color_selected] = rgb_buffer[color_selected]; 
0684:  BCF    03.0
0685:  RLF    5F,W
0686:  ADDLW  34
0687:  MOVWF  78
0688:  CLRF   7A
0689:  BTFSC  03.0
068A:  INCF   7A,F
068B:  MOVF   78,W
068C:  BSF    03.5
068D:  MOVWF  35
068E:  MOVF   7A,W
068F:  MOVWF  36
0690:  BCF    03.0
0691:  BCF    03.5
0692:  RLF    5F,W
0693:  ADDLW  2E
0694:  MOVWF  04
0695:  BCF    03.7
0696:  INCF   04,F
0697:  MOVF   00,W
0698:  MOVWF  7A
0699:  DECF   04,F
069A:  MOVF   00,W
069B:  BSF    03.5
069C:  MOVWF  37
069D:  MOVF   7A,W
069E:  MOVWF  38
069F:  MOVF   35,W
06A0:  MOVWF  04
06A1:  BCF    03.7
06A2:  BTFSC  36.0
06A3:  BSF    03.7
06A4:  INCF   04,F
06A5:  MOVF   38,W
06A6:  MOVWF  00
06A7:  DECF   04,F
06A8:  MOVF   37,W
06A9:  MOVWF  00
....................             color_selected = (++color_selected%3); 
06AA:  BCF    03.5
06AB:  INCF   5F,F
06AC:  MOVF   5F,W
06AD:  BSF    03.5
06AE:  MOVWF  42
06AF:  MOVLW  03
06B0:  MOVWF  43
06B1:  BCF    03.5
06B2:  CALL   1C1
06B3:  MOVF   77,W
06B4:  MOVWF  5F
....................             setCursor(cursor_map[color_selected], 1); 
06B5:  MOVLW  3A
06B6:  ADDWF  5F,W
06B7:  MOVWF  04
06B8:  BCF    03.7
06B9:  MOVF   00,W
06BA:  BSF    03.5
06BB:  MOVWF  35
06BC:  MOVWF  3E
06BD:  MOVLW  01
06BE:  MOVWF  3F
06BF:  BCF    03.5
06C0:  CALL   1D8
....................          } else { 
06C1:  GOTO   6C5
06C2:  BSF    03.5
....................             showErr(); 
06C3:  BCF    03.5
06C4:  CALL   2FD
....................          } 
....................       }  
....................        
....................       delay_ms(200);  
06C5:  MOVLW  C8
06C6:  BSF    03.5
06C7:  MOVWF  3A
06C8:  BCF    03.5
06C9:  CALL   06B
06CA:  BSF    03.5
....................    } 
.................... } 
....................  
.................... // scan 4x4 keyboard ports 
.................... void scanPorts() { 
....................    for (int linha = 0; linha <= 3; linha++) { 
*
0457:  BSF    03.5
0458:  CLRF   30
0459:  MOVF   30,W
045A:  SUBLW  03
045B:  BTFSS  03.0
045C:  GOTO   6E6
....................       output_low(linhas[linha]); 
045D:  MOVLW  46
045E:  ADDWF  30,W
045F:  MOVWF  04
0460:  BCF    03.7
0461:  MOVF   00,W
0462:  MOVWF  32
0463:  MOVWF  33
0464:  CLRF   34
0465:  CLRF   36
0466:  CLRF   35
0467:  BCF    03.5
0468:  CALL   1F3
0469:  BSF    03.5
046A:  MOVF   32,W
046B:  MOVWF  33
046C:  CLRF   34
046D:  CLRF   36
046E:  MOVLW  80
046F:  MOVWF  35
0470:  BCF    03.5
0471:  CALL   1F3
....................        
....................       for (int coluna = 0; coluna <= 3; coluna++) { 
0472:  BSF    03.5
0473:  CLRF   31
0474:  MOVF   31,W
0475:  SUBLW  03
0476:  BTFSS  03.0
0477:  GOTO   6CD
....................          // if pressed, deal with the input 
....................          if (!input(colunas[coluna])) { 
0478:  MOVLW  4A
0479:  ADDWF  31,W
047A:  MOVWF  04
047B:  BCF    03.7
047C:  MOVF   00,W
047D:  MOVWF  32
047E:  MOVWF  33
047F:  MOVLW  01
0480:  MOVWF  34
0481:  CLRF   36
0482:  MOVLW  80
0483:  MOVWF  35
0484:  BCF    03.5
0485:  CALL   1F3
0486:  BSF    03.5
0487:  MOVF   32,W
0488:  MOVWF  33
0489:  CLRF   35
048A:  CLRF   34
048B:  BCF    03.5
048C:  GOTO   215
048D:  BTFSC  78.0
048E:  GOTO   6CA
....................             user_input(input_array[linha][coluna]); 
048F:  BSF    03.5
0490:  RLF    30,W
0491:  MOVWF  77
0492:  RLF    77,F
0493:  MOVLW  FC
0494:  ANDWF  77,F
0495:  MOVF   77,W
0496:  ADDWF  31,W
0497:  ADDLW  4E
0498:  MOVWF  04
0499:  BCF    03.7
049A:  MOVF   00,W
049B:  MOVWF  32
049C:  CLRF   34
049D:  MOVF   32,W
049E:  MOVWF  33
....................          } 
*
06CB:  INCF   31,F
06CC:  GOTO   474
....................       } 
....................        
....................       output_high(linhas[linha]); 
06CD:  MOVLW  46
06CE:  ADDWF  30,W
06CF:  MOVWF  04
06D0:  BCF    03.7
06D1:  MOVF   00,W
06D2:  MOVWF  32
06D3:  MOVWF  33
06D4:  MOVLW  01
06D5:  MOVWF  34
06D6:  CLRF   36
06D7:  CLRF   35
06D8:  BCF    03.5
06D9:  CALL   1F3
06DA:  BSF    03.5
06DB:  MOVF   32,W
06DC:  MOVWF  33
06DD:  CLRF   34
06DE:  CLRF   36
06DF:  MOVLW  80
06E0:  MOVWF  35
06E1:  BCF    03.5
06E2:  CALL   1F3
06E3:  BSF    03.5
06E4:  INCF   30,F
06E5:  GOTO   459
....................    } 
.................... } 
....................  
....................  
....................  
.................... #use FIXED_IO(B_outputs=PIN_B4, PIN_B5, PIN_B6, PIN_B7) 
.................... #use FIXED_IO(D_outputs=PIN_D0, PIN_D1, PIN_D2) 
....................  
.................... // count from 0 to 255 
.................... uint8_t counter = 0; 
....................  
.................... #INT_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    // it checks if the color value is greater than the pulse 
....................    // ex: if 127, when counter < 127 it is on, if >= 127 it is off 
....................    // do this for all leds and output_d 
....................    output_d(0b00000000 | ((rgb_map[1]>counter)<<2) | ((rgb_map[0]>counter)<<1) |  ((rgb_map[2]>counter))); 
*
0031:  MOVF   37,F
0032:  BTFSS  03.2
0033:  GOTO   03A
0034:  MOVF   36,W
0035:  SUBWF  60,W
0036:  BTFSS  03.0
0037:  GOTO   03A
0038:  MOVLW  00
0039:  GOTO   03B
003A:  MOVLW  01
003B:  MOVWF  77
003C:  RLF    77,F
003D:  RLF    77,F
003E:  MOVLW  FC
003F:  ANDWF  77,F
0040:  MOVF   77,W
0041:  BSF    03.5
0042:  MOVWF  5F
0043:  BCF    03.5
0044:  MOVF   35,F
0045:  BTFSS  03.2
0046:  GOTO   04D
0047:  MOVF   34,W
0048:  SUBWF  60,W
0049:  BTFSS  03.0
004A:  GOTO   04D
004B:  MOVLW  00
004C:  GOTO   04E
004D:  MOVLW  01
004E:  MOVWF  77
004F:  BCF    03.0
0050:  RLF    77,F
0051:  MOVF   77,W
0052:  BSF    03.5
0053:  IORWF  5F,F
0054:  BCF    03.5
0055:  MOVF   39,F
0056:  BTFSS  03.2
0057:  GOTO   05E
0058:  MOVF   38,W
0059:  SUBWF  60,W
005A:  BTFSS  03.0
005B:  GOTO   05E
005C:  MOVLW  00
005D:  GOTO   05F
005E:  MOVLW  01
005F:  BSF    03.5
0060:  IORWF  5F,F
0061:  MOVLW  F8
0062:  MOVWF  08
0063:  MOVF   5F,W
0064:  BCF    03.5
0065:  MOVWF  08
....................    counter++; 
0066:  INCF   60,F
0067:  BCF    0C.1
0068:  BCF    0A.3
0069:  BCF    0A.4
006A:  GOTO   01D
.................... } 
....................  
....................  
.................... void main() 
*
037D:  MOVF   03,W
037E:  ANDLW  1F
037F:  MOVWF  03
0380:  MOVLW  FF
0381:  MOVWF  2D
0382:  BSF    2D.3
0383:  MOVF   2D,W
0384:  BSF    03.5
0385:  MOVWF  07
0386:  BCF    03.5
0387:  BSF    2D.4
0388:  MOVF   2D,W
0389:  BSF    03.5
038A:  MOVWF  07
038B:  MOVLW  31
038C:  MOVWF  13
038D:  MOVLW  28
038E:  BCF    03.5
038F:  MOVWF  14
0390:  BSF    03.5
0391:  BSF    14.7
0392:  BCF    14.6
0393:  MOVLW  08
0394:  BCF    03.5
0395:  MOVWF  3E
0396:  CLRF   45
0397:  CLRF   44
0398:  CLRF   5E
0399:  CLRF   5F
039A:  CLRF   60
039B:  BSF    03.5
039C:  BSF    1F.0
039D:  BSF    1F.1
039E:  BSF    1F.2
039F:  BCF    1F.3
03A0:  MOVLW  07
03A1:  MOVWF  1C
03A2:  BCF    03.7
.................... { 
....................    // PIC uses 7 bit + R/W  
....................    // 0x4E = 0x27 << 7  
....................    initializeLCD(0x4E, 16, 2); 
*
03E8:  MOVLW  4E
03E9:  BSF    03.5
03EA:  MOVWF  30
03EB:  MOVLW  10
03EC:  MOVWF  31
03ED:  MOVLW  02
03EE:  MOVWF  32
03EF:  BCF    03.5
03F0:  GOTO   109
....................     
....................    port_B_pullups(0xFF); 
03F1:  BSF    03.5
03F2:  BCF    01.7
....................    delay_ms(1000); 
03F3:  MOVLW  04
03F4:  MOVWF  71
03F5:  MOVLW  FA
03F6:  MOVWF  3A
03F7:  BCF    03.5
03F8:  CALL   06B
03F9:  DECFSZ 71,F
03FA:  GOTO   3FC
03FB:  GOTO   3FE
03FC:  BSF    03.5
03FD:  GOTO   3F5
....................        
....................    char c[16] = "Escolha a cor: "; 
03FE:  MOVLW  45
03FF:  MOVWF  61
0400:  MOVLW  73
0401:  MOVWF  62
0402:  MOVLW  63
0403:  MOVWF  63
0404:  MOVLW  6F
0405:  MOVWF  64
0406:  MOVLW  6C
0407:  MOVWF  65
0408:  MOVLW  68
0409:  MOVWF  66
040A:  MOVLW  61
040B:  MOVWF  67
040C:  MOVLW  20
040D:  MOVWF  68
040E:  MOVLW  61
040F:  MOVWF  69
0410:  MOVLW  20
0411:  MOVWF  6A
0412:  MOVLW  63
0413:  MOVWF  6B
0414:  MOVLW  6F
0415:  MOVWF  6C
0416:  MOVLW  72
0417:  MOVWF  6D
0418:  MOVLW  3A
0419:  MOVWF  6E
041A:  MOVLW  20
041B:  MOVWF  6F
041C:  CLRF   70
....................    printstr(c); 
041D:  BSF    03.5
041E:  CLRF   50
041F:  MOVLW  61
0420:  MOVWF  4F
0421:  BCF    03.5
0422:  CALL   19F
....................     
....................    setCursor(0,1); 
0423:  BSF    03.5
0424:  CLRF   3E
0425:  MOVLW  01
0426:  MOVWF  3F
0427:  BCF    03.5
0428:  CALL   1D8
....................     
....................    char d[16] = "R000 G000 B000"; 
0429:  MOVLW  52
042A:  BSF    03.5
042B:  MOVWF  20
042C:  MOVLW  30
042D:  MOVWF  21
042E:  MOVWF  22
042F:  MOVWF  23
0430:  MOVLW  20
0431:  MOVWF  24
0432:  MOVLW  47
0433:  MOVWF  25
0434:  MOVLW  30
0435:  MOVWF  26
0436:  MOVWF  27
0437:  MOVWF  28
0438:  MOVLW  20
0439:  MOVWF  29
043A:  MOVLW  42
043B:  MOVWF  2A
043C:  MOVLW  30
043D:  MOVWF  2B
043E:  MOVWF  2C
043F:  MOVWF  2D
0440:  CLRF   2E
....................    printstr(d); 
0441:  CLRF   50
0442:  MOVLW  A0
0443:  MOVWF  4F
0444:  BCF    03.5
0445:  CALL   19F
....................     
....................    setCursor(1,1); 
0446:  MOVLW  01
0447:  BSF    03.5
0448:  MOVWF  3E
0449:  MOVWF  3F
044A:  BCF    03.5
044B:  CALL   1D8
....................     
....................    setup_timer_2(T2_DIV_BY_4,5,13);      //4,8 us overflow, 62,4 us interrupt 
044C:  MOVLW  60
044D:  MOVWF  78
044E:  IORLW  05
044F:  MOVWF  12
0450:  MOVLW  05
0451:  BSF    03.5
0452:  MOVWF  12
....................    enable_interrupts(INT_TIMER2); 
0453:  BSF    0C.1
....................    enable_interrupts(GLOBAL);    
0454:  MOVLW  C0
0455:  BCF    03.5
0456:  IORWF  0B,F
....................     
....................    while(TRUE) scanPorts(); 
*
06E6:  GOTO   458
.................... } 
....................  
06E7:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
