CCS PCM C Compiler, Version 5.008, 5967               27-mai-18 11:28

               Filename:   C:\Users\vbob\Desktop\Engenharia\7º Período\Microcontroladores\fita_led\codigo\main.lst

               ROM used:   1117 words (14%)
                           Largest free fragment is 2048
               RAM used:   34 (9%) at main() level
                           93 (25%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   22F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.1
001A:  GOTO   01D
001B:  BTFSC  0C.1
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   031
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
*
0138:  MOVF   62,W
0139:  ANDLW  07
013A:  MOVWF  77
013B:  RRF    62,W
013C:  MOVWF  78
013D:  RRF    78,F
013E:  RRF    78,F
013F:  MOVLW  1F
0140:  ANDWF  78,F
0141:  MOVF   78,W
0142:  ADDWF  64,W
0143:  MOVWF  04
0144:  BCF    03.7
0145:  BTFSC  65.0
0146:  BSF    03.7
0147:  CLRF   78
0148:  INCF   78,F
0149:  INCF   77,F
014A:  GOTO   14C
014B:  RLF    78,F
014C:  DECFSZ 77,F
014D:  GOTO   14B
014E:  MOVF   63,F
014F:  BTFSC  03.2
0150:  GOTO   154
0151:  MOVF   78,W
0152:  IORWF  00,F
0153:  GOTO   157
0154:  COMF   78,F
0155:  MOVF   78,W
0156:  ANDWF  00,F
0157:  RETURN
0158:  MOVLW  10
0159:  MOVWF  67
015A:  CLRF   77
015B:  CLRF   7A
015C:  RRF    64,F
015D:  RRF    63,F
015E:  BTFSS  03.0
015F:  GOTO   166
0160:  MOVF   65,W
0161:  ADDWF  77,F
0162:  BTFSC  03.0
0163:  INCF   7A,F
0164:  MOVF   66,W
0165:  ADDWF  7A,F
0166:  RRF    7A,F
0167:  RRF    77,F
0168:  RRF    79,F
0169:  RRF    78,F
016A:  DECFSZ 67,F
016B:  GOTO   15C
016C:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
025C:  BCF    03.5
025D:  CLRF   27
025E:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
....................  
.................... #use delay(crystal=20000000) 
*
0067:  MOVLW  74
0068:  MOVWF  04
0069:  BCF    03.7
006A:  MOVF   00,W
006B:  BTFSC  03.2
006C:  GOTO   07A
006D:  MOVLW  06
006E:  MOVWF  78
006F:  CLRF   77
0070:  DECFSZ 77,F
0071:  GOTO   070
0072:  DECFSZ 78,F
0073:  GOTO   06F
0074:  MOVLW  7B
0075:  MOVWF  77
0076:  DECFSZ 77,F
0077:  GOTO   076
0078:  DECFSZ 00,F
0079:  GOTO   06D
007A:  RETURN
*
00BD:  MOVLW  03
00BE:  SUBWF  5D,F
00BF:  BTFSS  03.0
00C0:  GOTO   0CB
00C1:  MOVLW  5D
00C2:  MOVWF  04
00C3:  BCF    03.7
00C4:  MOVF   00,W
00C5:  BTFSC  03.2
00C6:  GOTO   0CB
00C7:  GOTO   0C9
00C8:  GOTO   0C9
00C9:  DECFSZ 00,F
00CA:  GOTO   0C8
00CB:  RETURN
.................... #use i2c(MASTER, I2C1, FORCE_HW)  
*
007B:  BCF    14.7
007C:  BCF    0C.3
007D:  MOVF   75,W
007E:  MOVWF  13
007F:  MOVLW  02
0080:  BTFSC  14.7
0081:  GOTO   089
0082:  BTFSS  0C.3
0083:  GOTO   082
0084:  MOVLW  00
0085:  BSF    03.5
0086:  BTFSC  11.6
0087:  MOVLW  01
0088:  BCF    03.5
0089:  MOVWF  78
008A:  RETURN
....................  
.................... #include <16x2_pcf8574.c> 
.................... // flags for control 
.................... #define LCD_CLEARDISPLAY 0x01 
.................... #define LCD_RETURNHOME 0x02 
.................... #define LCD_ENTRYMODESET 0x04 
.................... #define LCD_DISPLAYCONTROL 0x08 
.................... #define LCD_CURSORSHIFT 0x10 
.................... #define LCD_FUNCTIONSET 0x20 
.................... #define LCD_SETCGRAMADDR 0x40 
.................... #define LCD_SETDDRAMADDR 0x80 
....................  
.................... // flags for display entry mode 
.................... #define LCD_ENTRYRIGHT 0x00 
.................... #define LCD_ENTRYLEFT 0x02 
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01 
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00 
....................  
....................  
.................... // flags for display on/off control 
.................... #define LCD_DISPLAYON 0x04 
.................... #define LCD_DISPLAYOFF 0x00 
.................... #define LCD_CURSORON 0x02 
.................... #define LCD_CURSOROFF 0x00 
.................... #define LCD_BLINKON 0x01 
.................... #define LCD_BLINKOFF 0x00 
....................  
.................... // flags for display/cursor shift 
.................... #define LCD_DISPLAYMOVE 0x08 
.................... #define LCD_CURSORMOVE 0x00 
.................... #define LCD_MOVERIGHT 0x04 
.................... #define LCD_MOVELEFT 0x00 
....................  
.................... // flags for function set 
.................... #define LCD_8BITMODE 0x10 
.................... #define LCD_4BITMODE 0x00 
.................... #define LCD_2LINE 0x08 
.................... #define LCD_1LINE 0x00 
.................... #define LCD_5x10DOTS 0x04 
.................... #define LCD_5x8DOTS 0x00 
....................  
.................... // flags for backlight control 
.................... #define LCD_BACKLIGHT 0x08 
.................... #define LCD_NOBACKLIGHT 0x00 
....................  
.................... // function flags 
.................... #define En 0b00000100  // Enable bit 
.................... #define Rw 0b00000010  // Read/Write bit 
.................... #define Rs 0b00000001  // Register select bit 
....................  
.................... uint8_t _address; 
.................... uint8_t _backlightVal = LCD_BACKLIGHT; 
.................... uint8_t _displayControl; 
.................... uint8_t _displayFunction; 
.................... uint8_t _displayMode; 
.................... uint8_t _rows; 
.................... uint8_t _columns; 
....................  
.................... // sends code to pcf8574 so it redirects to the display 
.................... void expanderWrite(uint8_t _data) { 
....................    I2C_Start(); 
008B:  BSF    03.5
008C:  BSF    11.0
008D:  BTFSC  11.0
008E:  GOTO   08D
....................    I2C_Write(_address); 
008F:  BCF    03.5
0090:  MOVF   2A,W
0091:  MOVWF  75
0092:  CALL   07B
....................    delay_ms(5);  
0093:  MOVLW  05
0094:  MOVWF  74
0095:  CALL   067
....................    I2C_Write((int)(_data) | _backlightval); 
0096:  MOVF   73,W
0097:  IORWF  2B,W
0098:  MOVWF  74
0099:  MOVWF  75
009A:  CALL   07B
....................    I2C_stop(); 
009B:  BSF    03.5
009C:  BSF    11.2
009D:  BTFSC  11.2
009E:  GOTO   09D
....................    delay_ms(1);  
009F:  MOVLW  01
00A0:  MOVWF  74
00A1:  BCF    03.5
00A2:  CALL   067
00A3:  RETURN
.................... } 
....................  
....................  
.................... void initializeLCD(uint8_t address, uint8_t columns, uint8_t rows) { 
....................    _address = address; 
*
005E:  MOVF   5C,W
005F:  MOVWF  2A
....................    _columns = columns; 
0060:  MOVF   5D,W
0061:  MOVWF  30
....................    _rows = rows; 
0062:  MOVF   5E,W
0063:  MOVWF  2F
0064:  BCF    0A.3
0065:  BCF    0A.4
0066:  GOTO   266 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void pulseEnable(uint8_t _data) { 
....................    expanderWrite(_data | En); 
*
00A9:  MOVF   71,W
00AA:  IORLW  04
00AB:  MOVWF  72
00AC:  MOVWF  73
00AD:  CALL   08B
....................    delay_us(1); 
00AE:  GOTO   0AF
00AF:  GOTO   0B0
00B0:  NOP
....................     
....................    expanderWrite(_data & ~En); 
00B1:  MOVF   71,W
00B2:  ANDLW  FB
00B3:  MOVWF  72
00B4:  MOVWF  73
00B5:  CALL   08B
....................    delay_us(50); 
00B6:  MOVLW  52
00B7:  MOVWF  77
00B8:  DECFSZ 77,F
00B9:  GOTO   0B8
00BA:  GOTO   0BB
00BB:  NOP
.................... } 
....................  
.................... void write4bits(uint8_t value) { 
....................    expanderWrite(value); 
*
00A4:  MOVF   70,W
00A5:  MOVWF  73
00A6:  CALL   08B
....................    pulseEnable(value); 
00A7:  MOVF   70,W
00A8:  MOVWF  71
*
00BC:  RETURN
.................... } 
....................  
.................... void send(uint8_t value, uint8_t mode) { 
*
00CC:  MOVF   6B,W
00CD:  ANDLW  F0
00CE:  MOVWF  6D
00CF:  SWAPF  6B,W
00D0:  MOVWF  77
00D1:  MOVLW  F0
00D2:  ANDWF  77,F
00D3:  MOVF   77,W
00D4:  ANDLW  F0
00D5:  MOVWF  6E
....................    uint8_t MSB = value & 0b11110000; 
....................    uint8_t LSB = (value << 4) & 0b11110000; 
....................    write4bits((MSB)|mode); 
00D6:  MOVF   6D,W
00D7:  IORWF  6C,W
00D8:  MOVWF  6F
00D9:  MOVWF  70
00DA:  CALL   0A4
....................    write4bits((LSB)|mode); 
00DB:  MOVF   6E,W
00DC:  IORWF  6C,W
00DD:  MOVWF  6F
00DE:  MOVWF  70
00DF:  CALL   0A4
00E0:  RETURN
.................... } 
....................  
.................... void command(uint8_t value) { 
....................    send(value, 0); 
00E1:  MOVF   6A,W
00E2:  MOVWF  6B
00E3:  CLRF   6C
00E4:  CALL   0CC
00E5:  RETURN
.................... } 
....................  
.................... void display() { 
....................    _displayControl |= LCD_DISPLAYON; 
00E6:  BSF    2C.2
....................    command(LCD_DISPLAYCONTROL | _displayControl); 
00E7:  MOVF   2C,W
00E8:  IORLW  08
00E9:  MOVWF  5C
00EA:  MOVWF  6A
00EB:  CALL   0E1
00EC:  BCF    0A.3
00ED:  BCF    0A.4
00EE:  GOTO   2B5 (RETURN)
.................... } 
....................  
.................... void clear() { 
....................    command(LCD_CLEARDISPLAY); 
00EF:  MOVLW  01
00F0:  MOVWF  6A
00F1:  CALL   0E1
....................    delay_us(2000); 
00F2:  MOVLW  02
00F3:  MOVWF  74
00F4:  CALL   067
00F5:  BCF    0A.3
00F6:  BCF    0A.4
00F7:  GOTO   2B6 (RETURN)
.................... } 
....................  
.................... void home() { 
....................    command(LCD_RETURNHOME); 
00F8:  MOVLW  02
00F9:  MOVWF  6A
00FA:  CALL   0E1
....................    delay_us(2000); 
00FB:  MOVLW  02
00FC:  MOVWF  74
00FD:  CALL   067
00FE:  BCF    0A.3
00FF:  BCF    0A.4
0100:  GOTO   2BE (RETURN)
.................... } 
....................  
.................... int write(uint8_t value) { 
....................    send(value, Rs); 
0101:  MOVF   61,W
0102:  MOVWF  6B
0103:  MOVLW  01
0104:  MOVWF  6C
0105:  CALL   0CC
....................    return 1; 
0106:  MOVLW  01
0107:  MOVWF  78
0108:  RETURN
.................... } 
....................  
.................... void printstr(char *c[]) { 
0109:  CLRF   5E
....................    int i = 0; 
....................    while (c[i]) { 
010A:  MOVF   5E,W
010B:  ADDWF  5C,W
010C:  MOVWF  04
010D:  BCF    03.7
010E:  BTFSC  5D.0
010F:  BSF    03.7
0110:  MOVF   00,F
0111:  BTFSC  03.2
0112:  GOTO   11F
....................       write(c[i]); 
0113:  MOVF   5E,W
0114:  ADDWF  5C,W
0115:  MOVWF  04
0116:  BCF    03.7
0117:  BTFSC  5D.0
0118:  BSF    03.7
0119:  MOVF   00,W
011A:  MOVWF  5F
011B:  MOVWF  61
011C:  CALL   101
....................       i++; 
011D:  INCF   5E,F
011E:  GOTO   10A
....................    } 
011F:  RETURN
.................... } 
....................  
.................... void setCursor(uint8_t col, uint8_t row){ 
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 }; 
0120:  CLRF   65
0121:  MOVLW  40
0122:  MOVWF  66
0123:  MOVLW  14
0124:  MOVWF  67
0125:  MOVLW  54
0126:  MOVWF  68
....................    if (row > 2) { 
0127:  MOVF   64,W
0128:  SUBLW  02
0129:  BTFSC  03.0
012A:  GOTO   12D
....................       row = 2-1;    // we count rows starting w/0 
012B:  MOVLW  01
012C:  MOVWF  64
....................    } 
....................    command(LCD_SETDDRAMADDR | (col + row_offsets[row])); 
012D:  MOVLW  65
012E:  ADDWF  64,W
012F:  MOVWF  04
0130:  BCF    03.7
0131:  MOVF   00,W
0132:  ADDWF  63,W
0133:  IORLW  80
0134:  MOVWF  69
0135:  MOVWF  6A
0136:  CALL   0E1
0137:  RETURN
.................... } 
....................  
.................... #define LINHA0 PIN_B7 
.................... #define LINHA1 PIN_B6 
.................... #define LINHA2 PIN_B5 
.................... #define LINHA3 PIN_B4 
.................... #define COLUN0 PIN_B3 
.................... #define COLUN1 PIN_B2 
.................... #define COLUN2 PIN_B1 
.................... #define COLUN3 PIN_B0 
....................  
.................... #use FIXED_IO(B_outputs=PIN_B4, PIN_B5, PIN_B6, PIN_B7) 
.................... #use FIXED_IO(D_outputs=PIN_D0, PIN_D1, PIN_D2) 
.................... #use FIXED_IO(C_outputs=PIN_C5) 
.................... uint8_t pos_cursor = 1; 
....................  
.................... uint16_t red = 0; 
.................... uint16_t green = 0; 
.................... uint16_t blue = 0; 
....................  
.................... uint8_t red1 = 0; 
.................... uint8_t green1 = 0; 
.................... uint8_t blue1 = 0; 
....................  
.................... #define RED_PIN PIN_D1 
.................... #define GREEN_PIN PIN_D0 
.................... #define BLUE_PIN PIN_D2 
....................  
.................... void jumpCursor(uint16_t digited) { 
....................    if (pos_cursor == 2) { 
*
016D:  MOVF   31,W
016E:  SUBLW  02
016F:  BTFSS  03.2
0170:  GOTO   17D
....................        red = digited*100; 
0171:  MOVF   62,W
0172:  MOVWF  64
0173:  MOVF   61,W
0174:  MOVWF  63
0175:  CLRF   66
0176:  MOVLW  64
0177:  MOVWF  65
0178:  CALL   158
0179:  MOVF   79,W
017A:  MOVWF  33
017B:  MOVF   78,W
017C:  MOVWF  32
....................    } 
....................    if (pos_cursor == 3) { 
017D:  MOVF   31,W
017E:  SUBLW  03
017F:  BTFSS  03.2
0180:  GOTO   18F
....................        red+=digited*10; 
0181:  MOVF   62,W
0182:  MOVWF  64
0183:  MOVF   61,W
0184:  MOVWF  63
0185:  CLRF   66
0186:  MOVLW  0A
0187:  MOVWF  65
0188:  CALL   158
0189:  MOVF   78,W
018A:  ADDWF  32,F
018B:  MOVF   79,W
018C:  BTFSC  03.0
018D:  INCFSZ 79,W
018E:  ADDWF  33,F
....................    } 
....................    if (pos_cursor == 4) { 
018F:  MOVF   31,W
0190:  SUBLW  04
0191:  BTFSS  03.2
0192:  GOTO   1AD
....................       red+=digited; 
0193:  MOVF   61,W
0194:  ADDWF  32,F
0195:  MOVF   62,W
0196:  BTFSC  03.0
0197:  INCFSZ 62,W
0198:  ADDWF  33,F
....................       if (red>255) { 
0199:  MOVF   33,W
019A:  SUBLW  00
019B:  BTFSC  03.0
019C:  GOTO   1A4
....................          setCursor(1,1); 
019D:  MOVLW  01
019E:  MOVWF  63
019F:  MOVWF  64
01A0:  CALL   120
....................          pos_cursor = 1; 
01A1:  MOVLW  01
01A2:  MOVWF  31
....................       } 
01A3:  GOTO   1AD
....................       else { 
....................          setCursor(6,1); 
01A4:  MOVLW  06
01A5:  MOVWF  63
01A6:  MOVLW  01
01A7:  MOVWF  64
01A8:  CALL   120
....................          pos_cursor = 6; 
01A9:  MOVLW  06
01AA:  MOVWF  31
....................          red1 = red; 
01AB:  MOVF   32,W
01AC:  MOVWF  38
....................       } 
....................        
....................    } 
....................    if (pos_cursor == 7) { 
01AD:  MOVF   31,W
01AE:  SUBLW  07
01AF:  BTFSS  03.2
01B0:  GOTO   1BD
....................        green = digited * 100; 
01B1:  MOVF   62,W
01B2:  MOVWF  64
01B3:  MOVF   61,W
01B4:  MOVWF  63
01B5:  CLRF   66
01B6:  MOVLW  64
01B7:  MOVWF  65
01B8:  CALL   158
01B9:  MOVF   79,W
01BA:  MOVWF  35
01BB:  MOVF   78,W
01BC:  MOVWF  34
....................    } 
....................    if (pos_cursor ==8) { 
01BD:  MOVF   31,W
01BE:  SUBLW  08
01BF:  BTFSS  03.2
01C0:  GOTO   1CF
....................        green += digited * 10; 
01C1:  MOVF   62,W
01C2:  MOVWF  64
01C3:  MOVF   61,W
01C4:  MOVWF  63
01C5:  CLRF   66
01C6:  MOVLW  0A
01C7:  MOVWF  65
01C8:  CALL   158
01C9:  MOVF   78,W
01CA:  ADDWF  34,F
01CB:  MOVF   79,W
01CC:  BTFSC  03.0
01CD:  INCFSZ 79,W
01CE:  ADDWF  35,F
....................    } 
....................    if (pos_cursor == 9) { 
01CF:  MOVF   31,W
01D0:  SUBLW  09
01D1:  BTFSS  03.2
01D2:  GOTO   1EE
....................       green += digited; 
01D3:  MOVF   61,W
01D4:  ADDWF  34,F
01D5:  MOVF   62,W
01D6:  BTFSC  03.0
01D7:  INCFSZ 62,W
01D8:  ADDWF  35,F
....................        if (green>255) { 
01D9:  MOVF   35,W
01DA:  SUBLW  00
01DB:  BTFSC  03.0
01DC:  GOTO   1E5
....................          setCursor(6,1); 
01DD:  MOVLW  06
01DE:  MOVWF  63
01DF:  MOVLW  01
01E0:  MOVWF  64
01E1:  CALL   120
....................          pos_cursor = 6; 
01E2:  MOVLW  06
01E3:  MOVWF  31
....................       } 
01E4:  GOTO   1EE
....................       else { 
....................          setCursor(11,1); 
01E5:  MOVLW  0B
01E6:  MOVWF  63
01E7:  MOVLW  01
01E8:  MOVWF  64
01E9:  CALL   120
....................          pos_cursor = 11; 
01EA:  MOVLW  0B
01EB:  MOVWF  31
....................          green1 = green; 
01EC:  MOVF   34,W
01ED:  MOVWF  39
....................       } 
....................    } 
....................    if (pos_cursor == 12) { 
01EE:  MOVF   31,W
01EF:  SUBLW  0C
01F0:  BTFSS  03.2
01F1:  GOTO   1FE
....................        blue = digited * 100; 
01F2:  MOVF   62,W
01F3:  MOVWF  64
01F4:  MOVF   61,W
01F5:  MOVWF  63
01F6:  CLRF   66
01F7:  MOVLW  64
01F8:  MOVWF  65
01F9:  CALL   158
01FA:  MOVF   79,W
01FB:  MOVWF  37
01FC:  MOVF   78,W
01FD:  MOVWF  36
....................    } 
....................    if (pos_cursor ==13) { 
01FE:  MOVF   31,W
01FF:  SUBLW  0D
0200:  BTFSS  03.2
0201:  GOTO   210
....................        blue += digited * 10; 
0202:  MOVF   62,W
0203:  MOVWF  64
0204:  MOVF   61,W
0205:  MOVWF  63
0206:  CLRF   66
0207:  MOVLW  0A
0208:  MOVWF  65
0209:  CALL   158
020A:  MOVF   78,W
020B:  ADDWF  36,F
020C:  MOVF   79,W
020D:  BTFSC  03.0
020E:  INCFSZ 79,W
020F:  ADDWF  37,F
....................    } 
....................    if (pos_cursor == 14) { 
0210:  MOVF   31,W
0211:  SUBLW  0E
0212:  BTFSS  03.2
0213:  GOTO   22E
....................       blue += digited; 
0214:  MOVF   61,W
0215:  ADDWF  36,F
0216:  MOVF   62,W
0217:  BTFSC  03.0
0218:  INCFSZ 62,W
0219:  ADDWF  37,F
....................        
....................        
....................       if (blue>255) { 
021A:  MOVF   37,W
021B:  SUBLW  00
021C:  BTFSC  03.0
021D:  GOTO   226
....................          setCursor(11,1); 
021E:  MOVLW  0B
021F:  MOVWF  63
0220:  MOVLW  01
0221:  MOVWF  64
0222:  CALL   120
....................          pos_cursor = 1; 
0223:  MOVLW  01
0224:  MOVWF  31
....................       } 
0225:  GOTO   22E
....................       else { 
....................          setCursor(1,1); 
0226:  MOVLW  01
0227:  MOVWF  63
0228:  MOVWF  64
0229:  CALL   120
....................          pos_cursor = 1; 
022A:  MOVLW  01
022B:  MOVWF  31
....................          blue1 = blue; 
022C:  MOVF   36,W
022D:  MOVWF  3A
....................       } 
....................    } 
022E:  RETURN
.................... } 
....................  
.................... void scanPorts() { 
....................    uint8_t ports[] = {LINHA0, LINHA1, LINHA2, LINHA3}; 
*
031C:  MOVLW  37
031D:  MOVWF  5C
031E:  MOVLW  36
031F:  MOVWF  5D
0320:  MOVLW  35
0321:  MOVWF  5E
0322:  MOVLW  34
0323:  MOVWF  5F
....................  
....................    for (int linha = 0; linha <= 3; linha++) { 
0324:  CLRF   60
0325:  MOVF   60,W
0326:  SUBLW  03
0327:  BTFSS  03.0
0328:  GOTO   45B
....................       output_high(ports[0]); 
0329:  MOVF   5C,W
032A:  MOVWF  62
032B:  MOVLW  01
032C:  MOVWF  63
032D:  CLRF   65
032E:  CLRF   64
032F:  CALL   138
0330:  MOVF   5C,W
0331:  MOVWF  62
0332:  CLRF   63
0333:  CLRF   65
0334:  MOVLW  80
0335:  MOVWF  64
0336:  CALL   138
....................       output_high(ports[1]); 
0337:  MOVF   5D,W
0338:  MOVWF  62
0339:  MOVLW  01
033A:  MOVWF  63
033B:  CLRF   65
033C:  CLRF   64
033D:  CALL   138
033E:  MOVF   5D,W
033F:  MOVWF  62
0340:  CLRF   63
0341:  CLRF   65
0342:  MOVLW  80
0343:  MOVWF  64
0344:  CALL   138
....................       output_high(ports[2]); 
0345:  MOVF   5E,W
0346:  MOVWF  62
0347:  MOVLW  01
0348:  MOVWF  63
0349:  CLRF   65
034A:  CLRF   64
034B:  CALL   138
034C:  MOVF   5E,W
034D:  MOVWF  62
034E:  CLRF   63
034F:  CLRF   65
0350:  MOVLW  80
0351:  MOVWF  64
0352:  CALL   138
....................       output_high(ports[3]); 
0353:  MOVF   5F,W
0354:  MOVWF  62
0355:  MOVLW  01
0356:  MOVWF  63
0357:  CLRF   65
0358:  CLRF   64
0359:  CALL   138
035A:  MOVF   5F,W
035B:  MOVWF  62
035C:  CLRF   63
035D:  CLRF   65
035E:  MOVLW  80
035F:  MOVWF  64
0360:  CALL   138
....................       output_low(ports[linha]); 
0361:  MOVLW  5C
0362:  ADDWF  60,W
0363:  MOVWF  04
0364:  BCF    03.7
0365:  MOVF   00,W
0366:  MOVWF  61
0367:  MOVWF  62
0368:  CLRF   63
0369:  CLRF   65
036A:  CLRF   64
036B:  CALL   138
036C:  MOVF   61,W
036D:  MOVWF  62
036E:  CLRF   63
036F:  CLRF   65
0370:  MOVLW  80
0371:  MOVWF  64
0372:  CALL   138
....................        
....................       if (linha == 0 && !input(COLUN0)) { 
0373:  MOVF   60,F
0374:  BTFSS  03.2
0375:  GOTO   38A
0376:  MOVLW  0F
0377:  BSF    03.5
0378:  MOVWF  06
0379:  BCF    03.5
037A:  BTFSC  06.3
037B:  GOTO   38A
....................          write('1'); 
037C:  MOVLW  31
037D:  MOVWF  61
037E:  CALL   101
....................          pos_cursor++; 
037F:  INCF   31,F
....................          jumpCursor(1); 
0380:  CLRF   62
0381:  MOVLW  01
0382:  MOVWF  61
0383:  CALL   16D
....................          while(!input(COLUN0)); 
0384:  MOVLW  0F
0385:  BSF    03.5
0386:  MOVWF  06
0387:  BCF    03.5
0388:  BTFSS  06.3
0389:  GOTO   384
....................       } 
....................       if (linha == 0 && !input(COLUN1)) { 
038A:  MOVF   60,F
038B:  BTFSS  03.2
038C:  GOTO   3A1
038D:  MOVLW  0F
038E:  BSF    03.5
038F:  MOVWF  06
0390:  BCF    03.5
0391:  BTFSC  06.2
0392:  GOTO   3A1
....................          write('2'); 
0393:  MOVLW  32
0394:  MOVWF  61
0395:  CALL   101
....................          pos_cursor++; 
0396:  INCF   31,F
....................          jumpCursor(2); 
0397:  CLRF   62
0398:  MOVLW  02
0399:  MOVWF  61
039A:  CALL   16D
....................          while(!input(COLUN1)); 
039B:  MOVLW  0F
039C:  BSF    03.5
039D:  MOVWF  06
039E:  BCF    03.5
039F:  BTFSS  06.2
03A0:  GOTO   39B
....................       } 
....................       if (linha == 0 && !input(COLUN2)) { 
03A1:  MOVF   60,F
03A2:  BTFSS  03.2
03A3:  GOTO   3B8
03A4:  MOVLW  0F
03A5:  BSF    03.5
03A6:  MOVWF  06
03A7:  BCF    03.5
03A8:  BTFSC  06.1
03A9:  GOTO   3B8
....................          write('3'); 
03AA:  MOVLW  33
03AB:  MOVWF  61
03AC:  CALL   101
....................          pos_cursor++; 
03AD:  INCF   31,F
....................          jumpCursor(3); 
03AE:  CLRF   62
03AF:  MOVLW  03
03B0:  MOVWF  61
03B1:  CALL   16D
....................          while(!input(COLUN2)); 
03B2:  MOVLW  0F
03B3:  BSF    03.5
03B4:  MOVWF  06
03B5:  BCF    03.5
03B6:  BTFSS  06.1
03B7:  GOTO   3B2
....................       } 
....................       if (linha == 1 && !input(COLUN0)) { 
03B8:  DECFSZ 60,W
03B9:  GOTO   3CE
03BA:  MOVLW  0F
03BB:  BSF    03.5
03BC:  MOVWF  06
03BD:  BCF    03.5
03BE:  BTFSC  06.3
03BF:  GOTO   3CE
....................          write('4'); 
03C0:  MOVLW  34
03C1:  MOVWF  61
03C2:  CALL   101
....................          pos_cursor++; 
03C3:  INCF   31,F
....................          jumpCursor(4); 
03C4:  CLRF   62
03C5:  MOVLW  04
03C6:  MOVWF  61
03C7:  CALL   16D
....................          while(!input(COLUN0)); 
03C8:  MOVLW  0F
03C9:  BSF    03.5
03CA:  MOVWF  06
03CB:  BCF    03.5
03CC:  BTFSS  06.3
03CD:  GOTO   3C8
....................       } 
....................       if (linha == 1 && !input(COLUN1)) { 
03CE:  DECFSZ 60,W
03CF:  GOTO   3E4
03D0:  MOVLW  0F
03D1:  BSF    03.5
03D2:  MOVWF  06
03D3:  BCF    03.5
03D4:  BTFSC  06.2
03D5:  GOTO   3E4
....................          write('5'); 
03D6:  MOVLW  35
03D7:  MOVWF  61
03D8:  CALL   101
....................          pos_cursor++; 
03D9:  INCF   31,F
....................          jumpCursor(5); 
03DA:  CLRF   62
03DB:  MOVLW  05
03DC:  MOVWF  61
03DD:  CALL   16D
....................          while(!input(COLUN1)); 
03DE:  MOVLW  0F
03DF:  BSF    03.5
03E0:  MOVWF  06
03E1:  BCF    03.5
03E2:  BTFSS  06.2
03E3:  GOTO   3DE
....................       } 
....................       if (linha == 1 && !input(COLUN2)) { 
03E4:  DECFSZ 60,W
03E5:  GOTO   3FA
03E6:  MOVLW  0F
03E7:  BSF    03.5
03E8:  MOVWF  06
03E9:  BCF    03.5
03EA:  BTFSC  06.1
03EB:  GOTO   3FA
....................          write('6'); 
03EC:  MOVLW  36
03ED:  MOVWF  61
03EE:  CALL   101
....................          pos_cursor++; 
03EF:  INCF   31,F
....................          jumpCursor(6); 
03F0:  CLRF   62
03F1:  MOVLW  06
03F2:  MOVWF  61
03F3:  CALL   16D
....................          while(!input(COLUN2)); 
03F4:  MOVLW  0F
03F5:  BSF    03.5
03F6:  MOVWF  06
03F7:  BCF    03.5
03F8:  BTFSS  06.1
03F9:  GOTO   3F4
....................       } 
....................       if (linha == 2 && !input(COLUN0)) { 
03FA:  MOVF   60,W
03FB:  SUBLW  02
03FC:  BTFSS  03.2
03FD:  GOTO   412
03FE:  MOVLW  0F
03FF:  BSF    03.5
0400:  MOVWF  06
0401:  BCF    03.5
0402:  BTFSC  06.3
0403:  GOTO   412
....................          write('7'); 
0404:  MOVLW  37
0405:  MOVWF  61
0406:  CALL   101
....................          pos_cursor++; 
0407:  INCF   31,F
....................          jumpCursor(7); 
0408:  CLRF   62
0409:  MOVLW  07
040A:  MOVWF  61
040B:  CALL   16D
....................          while(!input(COLUN0)); 
040C:  MOVLW  0F
040D:  BSF    03.5
040E:  MOVWF  06
040F:  BCF    03.5
0410:  BTFSS  06.3
0411:  GOTO   40C
....................       } 
....................       if (linha == 2 && !input(COLUN1)) { 
0412:  MOVF   60,W
0413:  SUBLW  02
0414:  BTFSS  03.2
0415:  GOTO   42A
0416:  MOVLW  0F
0417:  BSF    03.5
0418:  MOVWF  06
0419:  BCF    03.5
041A:  BTFSC  06.2
041B:  GOTO   42A
....................          write('8'); 
041C:  MOVLW  38
041D:  MOVWF  61
041E:  CALL   101
....................          pos_cursor++; 
041F:  INCF   31,F
....................          jumpCursor(8); 
0420:  CLRF   62
0421:  MOVLW  08
0422:  MOVWF  61
0423:  CALL   16D
....................          while(!input(COLUN1)); 
0424:  MOVLW  0F
0425:  BSF    03.5
0426:  MOVWF  06
0427:  BCF    03.5
0428:  BTFSS  06.2
0429:  GOTO   424
....................       } 
....................       if (linha == 2 && !input(COLUN2)) { 
042A:  MOVF   60,W
042B:  SUBLW  02
042C:  BTFSS  03.2
042D:  GOTO   442
042E:  MOVLW  0F
042F:  BSF    03.5
0430:  MOVWF  06
0431:  BCF    03.5
0432:  BTFSC  06.1
0433:  GOTO   442
....................          write('9'); 
0434:  MOVLW  39
0435:  MOVWF  61
0436:  CALL   101
....................          pos_cursor++; 
0437:  INCF   31,F
....................          jumpCursor(9); 
0438:  CLRF   62
0439:  MOVLW  09
043A:  MOVWF  61
043B:  CALL   16D
....................          while(!input(COLUN2)); 
043C:  MOVLW  0F
043D:  BSF    03.5
043E:  MOVWF  06
043F:  BCF    03.5
0440:  BTFSS  06.1
0441:  GOTO   43C
....................       } 
....................       if (linha == 3 && !input(COLUN1)) { 
0442:  MOVF   60,W
0443:  SUBLW  03
0444:  BTFSS  03.2
0445:  GOTO   459
0446:  MOVLW  0F
0447:  BSF    03.5
0448:  MOVWF  06
0449:  BCF    03.5
044A:  BTFSC  06.2
044B:  GOTO   459
....................          write('0'); 
044C:  MOVLW  30
044D:  MOVWF  61
044E:  CALL   101
....................          pos_cursor++; 
044F:  INCF   31,F
....................          jumpCursor(0); 
0450:  CLRF   62
0451:  CLRF   61
0452:  CALL   16D
....................          while(!input(COLUN1)); 
0453:  MOVLW  0F
0454:  BSF    03.5
0455:  MOVWF  06
0456:  BCF    03.5
0457:  BTFSS  06.2
0458:  GOTO   453
....................       } 
0459:  INCF   60,F
045A:  GOTO   325
....................    } 
.................... } 
....................  
.................... uint8_t counter = 0; 
....................  
....................  
.................... #INT_TIMER2 
.................... void  TIMER2_isr(void)  
.................... { 
....................    output_d(0b00000000 | ((red1>counter)<<1) | ((blue1>counter)<<2) | ((green1>counter))); 
*
0031:  MOVF   38,W
0032:  SUBWF  3B,W
0033:  BTFSS  03.0
0034:  GOTO   037
0035:  MOVLW  00
0036:  GOTO   038
0037:  MOVLW  01
0038:  MOVWF  77
0039:  BCF    03.0
003A:  RLF    77,F
003B:  MOVF   77,W
003C:  MOVWF  7B
003D:  MOVF   3A,W
003E:  SUBWF  3B,W
003F:  BTFSS  03.0
0040:  GOTO   043
0041:  MOVLW  00
0042:  GOTO   044
0043:  MOVLW  01
0044:  MOVWF  77
0045:  RLF    77,F
0046:  RLF    77,F
0047:  MOVLW  FC
0048:  ANDWF  77,F
0049:  MOVF   77,W
004A:  IORWF  7B,F
004B:  MOVF   39,W
004C:  SUBWF  3B,W
004D:  BTFSS  03.0
004E:  GOTO   051
004F:  MOVLW  00
0050:  GOTO   052
0051:  MOVLW  01
0052:  IORWF  7B,F
0053:  MOVLW  F8
0054:  BSF    03.5
0055:  MOVWF  08
0056:  MOVF   7B,W
0057:  BCF    03.5
0058:  MOVWF  08
....................    counter++; 
0059:  INCF   3B,F
005A:  BCF    0C.1
005B:  BCF    0A.3
005C:  BCF    0A.4
005D:  GOTO   01D
.................... } 
....................  
....................  
.................... void main() 
*
022F:  MOVF   03,W
0230:  ANDLW  1F
0231:  MOVWF  03
0232:  MOVLW  FF
0233:  MOVWF  29
0234:  BSF    29.3
0235:  MOVF   29,W
0236:  BSF    03.5
0237:  MOVWF  07
0238:  BCF    03.5
0239:  BSF    29.4
023A:  MOVF   29,W
023B:  BSF    03.5
023C:  MOVWF  07
023D:  MOVLW  31
023E:  MOVWF  13
023F:  MOVLW  28
0240:  BCF    03.5
0241:  MOVWF  14
0242:  BSF    03.5
0243:  BSF    14.7
0244:  BCF    14.6
0245:  MOVLW  08
0246:  BCF    03.5
0247:  MOVWF  2B
0248:  MOVLW  01
0249:  MOVWF  31
024A:  CLRF   33
024B:  CLRF   32
024C:  CLRF   35
024D:  CLRF   34
024E:  CLRF   37
024F:  CLRF   36
0250:  CLRF   38
0251:  CLRF   39
0252:  CLRF   3A
0253:  CLRF   3B
0254:  BSF    03.5
0255:  BSF    1F.0
0256:  BSF    1F.1
0257:  BSF    1F.2
0258:  BCF    1F.3
0259:  MOVLW  07
025A:  MOVWF  1C
025B:  BCF    03.7
.................... { 
....................    initializeLCD(0x4E, 16, 2); 
*
025F:  MOVLW  4E
0260:  MOVWF  5C
0261:  MOVLW  10
0262:  MOVWF  5D
0263:  MOVLW  02
0264:  MOVWF  5E
0265:  GOTO   05E
....................     
....................    port_B_pullups(0xFF); 
0266:  BSF    03.5
0267:  BCF    01.7
....................    delay_ms(1000); 
0268:  MOVLW  04
0269:  BCF    03.5
026A:  MOVWF  5C
026B:  MOVLW  FA
026C:  MOVWF  74
026D:  CALL   067
026E:  DECFSZ 5C,F
026F:  GOTO   26B
....................    _displayFunction = LCD_4BITMODE | LCD_2LINE | LCD_5x8DOTS; 
0270:  MOVLW  08
0271:  MOVWF  2D
....................    delay_ms(500); 
0272:  MOVLW  02
0273:  MOVWF  5C
0274:  MOVLW  FA
0275:  MOVWF  74
0276:  CALL   067
0277:  DECFSZ 5C,F
0278:  GOTO   274
....................    expanderWrite(_backlightval); 
0279:  MOVF   2B,W
027A:  MOVWF  73
027B:  CALL   08B
....................    delay_ms(1000); 
027C:  MOVLW  04
027D:  MOVWF  5C
027E:  MOVLW  FA
027F:  MOVWF  74
0280:  CALL   067
0281:  DECFSZ 5C,F
0282:  GOTO   27E
....................     
....................    write4bits(0x03 << 4); 
0283:  MOVLW  30
0284:  MOVWF  70
0285:  CALL   0A4
....................    delay_us(4500); 
0286:  MOVLW  04
0287:  MOVWF  74
0288:  CALL   067
0289:  MOVLW  02
028A:  MOVWF  5C
028B:  MOVLW  F9
028C:  MOVWF  5D
028D:  CALL   0BD
028E:  DECFSZ 5C,F
028F:  GOTO   28B
....................     
....................    write4bits(0x03 << 4); 
0290:  MOVLW  30
0291:  MOVWF  70
0292:  CALL   0A4
....................    delay_us(4500); 
0293:  MOVLW  04
0294:  MOVWF  74
0295:  CALL   067
0296:  MOVLW  02
0297:  MOVWF  5C
0298:  MOVLW  F9
0299:  MOVWF  5D
029A:  CALL   0BD
029B:  DECFSZ 5C,F
029C:  GOTO   298
....................     
....................    write4bits(0x03 << 4); 
029D:  MOVLW  30
029E:  MOVWF  70
029F:  CALL   0A4
....................    delay_us(1500); 
02A0:  MOVLW  01
02A1:  MOVWF  74
02A2:  CALL   067
02A3:  MOVLW  02
02A4:  MOVWF  5C
02A5:  MOVLW  F9
02A6:  MOVWF  5D
02A7:  CALL   0BD
02A8:  DECFSZ 5C,F
02A9:  GOTO   2A5
....................     
....................    write4bits(0x02 << 4); 
02AA:  MOVLW  20
02AB:  MOVWF  70
02AC:  CALL   0A4
....................     
....................    command(LCD_FUNCTIONSET | _displayFunction); 
02AD:  MOVF   2D,W
02AE:  IORLW  20
02AF:  MOVWF  5C
02B0:  MOVWF  6A
02B1:  CALL   0E1
....................     
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSORON | LCD_BLINKON; 
02B2:  MOVLW  07
02B3:  MOVWF  2C
....................     
....................    display(); 
02B4:  GOTO   0E6
....................    clear(); 
02B5:  GOTO   0EF
....................     
....................    _displayMode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT; 
02B6:  MOVLW  02
02B7:  MOVWF  2E
....................     
....................    command(LCD_ENTRYMODESET | _displayMode); 
02B8:  MOVF   2E,W
02B9:  IORLW  04
02BA:  MOVWF  5C
02BB:  MOVWF  6A
02BC:  CALL   0E1
....................     
....................    home(); 
02BD:  GOTO   0F8
....................     
....................    char c[16] = "Escolha a cor: "; 
02BE:  MOVLW  45
02BF:  MOVWF  3C
02C0:  MOVLW  73
02C1:  MOVWF  3D
02C2:  MOVLW  63
02C3:  MOVWF  3E
02C4:  MOVLW  6F
02C5:  MOVWF  3F
02C6:  MOVLW  6C
02C7:  MOVWF  40
02C8:  MOVLW  68
02C9:  MOVWF  41
02CA:  MOVLW  61
02CB:  MOVWF  42
02CC:  MOVLW  20
02CD:  MOVWF  43
02CE:  MOVLW  61
02CF:  MOVWF  44
02D0:  MOVLW  20
02D1:  MOVWF  45
02D2:  MOVLW  63
02D3:  MOVWF  46
02D4:  MOVLW  6F
02D5:  MOVWF  47
02D6:  MOVLW  72
02D7:  MOVWF  48
02D8:  MOVLW  3A
02D9:  MOVWF  49
02DA:  MOVLW  20
02DB:  MOVWF  4A
02DC:  CLRF   4B
....................    printstr(c); 
02DD:  CLRF   5D
02DE:  MOVLW  3C
02DF:  MOVWF  5C
02E0:  CALL   109
....................     
....................    setCursor(0,1); 
02E1:  CLRF   63
02E2:  MOVLW  01
02E3:  MOVWF  64
02E4:  CALL   120
....................    char d[16] = "R000 G000 B000"; 
02E5:  MOVLW  52
02E6:  MOVWF  4C
02E7:  MOVLW  30
02E8:  MOVWF  4D
02E9:  MOVWF  4E
02EA:  MOVWF  4F
02EB:  MOVLW  20
02EC:  MOVWF  50
02ED:  MOVLW  47
02EE:  MOVWF  51
02EF:  MOVLW  30
02F0:  MOVWF  52
02F1:  MOVWF  53
02F2:  MOVWF  54
02F3:  MOVLW  20
02F4:  MOVWF  55
02F5:  MOVLW  42
02F6:  MOVWF  56
02F7:  MOVLW  30
02F8:  MOVWF  57
02F9:  MOVWF  58
02FA:  MOVWF  59
02FB:  CLRF   5A
....................    printstr(d); 
02FC:  CLRF   5D
02FD:  MOVLW  4C
02FE:  MOVWF  5C
02FF:  CALL   109
....................     
....................    setCursor(1,1); 
0300:  MOVLW  01
0301:  MOVWF  63
0302:  MOVWF  64
0303:  CALL   120
....................     
....................    output_high(BLUE_PIN); 
0304:  MOVLW  F8
0305:  BSF    03.5
0306:  MOVWF  08
0307:  BCF    03.5
0308:  BSF    08.2
....................    output_high(GREEN_PIN); 
0309:  BSF    03.5
030A:  MOVWF  08
030B:  BCF    03.5
030C:  BSF    08.0
....................    output_high(RED_PIN); 
030D:  BSF    03.5
030E:  MOVWF  08
030F:  BCF    03.5
0310:  BSF    08.1
....................     
....................    setup_timer_2(T2_DIV_BY_4,1,16); 
0311:  MOVLW  78
0312:  MOVWF  78
0313:  IORLW  05
0314:  MOVWF  12
0315:  MOVLW  01
0316:  BSF    03.5
0317:  MOVWF  12
....................    enable_interrupts(INT_TIMER2); 
0318:  BSF    0C.1
....................    enable_interrupts(GLOBAL);    
0319:  MOVLW  C0
031A:  BCF    03.5
031B:  IORWF  0B,F
....................     
....................    while(TRUE) scanPorts(); 
*
045B:  GOTO   31C
.................... } 
....................  
045C:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
